// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/communication_protocol/message_binding.proto

#ifndef PROTOBUF_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto__INCLUDED
#define PROTOBUF_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace network_messages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();

class service_obj;
class errorStatus;
class heartBeat;
class heartBeatAck;
class StopProxyAck;
class BlockRequestAck;
class TransferComponentsAck;
class TransferComponentsAck_pair;
class GetServiceComponentAck;
class GetServiceComponent;
class GetGlobalMap;
class GlobalMapInfo;
class GlobalMapInfo_service;
class LocalLeaderStartMonitoring;
class LocalLeaderStartMonitoringAck;
class OsdStartMonitoring;
class OsdStartMonitoringAck;
class RecvProcStartMonitoring;
class RecvProcStartMonitoringAck;
class RecvProcStartMonitoringAck_entry;
class CompTransferInfo;
class CompTransferInfo_pair;
class CompTranferFinalStat;
class CompTranferFinalStat_pair;
class TransferComp;
class TransferComp_pair;
class NodeAdditionCli;
class NodeAdditionCliAck;
class NodeAdditionCliAck_pair;
class NodeAdditionGl;
class NodeAdditionGlAck;
class NodeStopLL;
class NodeStopLLAck;
class NodeRetire;
class NodeRetireAck;
class NodeDeletionCli;
class NodeDeletionCliAck;
class NodeSystemStopCli;
class LocalNodeStatus;
class NodeStatus;
class NodeStatusAck;
class NodeStopCli;
class NodeStopCliAck;
class StopServices;
class StopServicesAck;
class NodeFailover;
class NodeFailoverAck;
class TakeGlOwnership;
class TakeGlOwnershipAck;
class GetObjectVersion;
class GetObjectVersionAck;
class NodeRejoinAfterRecovery;
class NodeRejoinAfterRecoveryAck;
class GetClusterStatus;
class GetClusterStatusAck;
class GetClusterStatusAck_pair;
class UpdateContainer;
class ReleaseTransactionLock;
class StatusAck;
class NodeAdditionFinalAck;

enum NodeStatusEnum {
  RUNNING = 10,
  STOPPING = 20,
  STOP = 30,
  REGISTERED = 40,
  FAILED = 50,
  RECOVERED = 60,
  RETIRING = 70,
  RETIRED = 80,
  NODE_STOPPING = 90,
  INVALID_NODE = 100,
  NEW = 110,
  RETIRING_FAILED = 120,
  RETIRED_RECOVERED = 130,
  IN_LOCAL_NODE_REC = 140,
  NODE_STOPPED = 150,
  TRANSITION_STATE = 160,
  REJOINING = 170
};
bool NodeStatusEnum_IsValid(int value);
const NodeStatusEnum NodeStatusEnum_MIN = RUNNING;
const NodeStatusEnum NodeStatusEnum_MAX = REJOINING;
const int NodeStatusEnum_ARRAYSIZE = NodeStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeStatusEnum_descriptor();
inline const ::std::string& NodeStatusEnum_Name(NodeStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeStatusEnum_descriptor(), value);
}
inline bool NodeStatusEnum_Parse(
    const ::std::string& name, NodeStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeStatusEnum>(
    NodeStatusEnum_descriptor(), name, value);
}
// ===================================================================

class service_obj : public ::google::protobuf::Message {
 public:
  service_obj();
  virtual ~service_obj();
  
  service_obj(const service_obj& from);
  
  inline service_obj& operator=(const service_obj& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const service_obj& default_instance();
  
  void Swap(service_obj* other);
  
  // implements Message ----------------------------------------------
  
  service_obj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const service_obj& from);
  void MergeFrom(const service_obj& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:network_messages.service_obj)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static service_obj* default_instance_;
};
// -------------------------------------------------------------------

class errorStatus : public ::google::protobuf::Message {
 public:
  errorStatus();
  virtual ~errorStatus();
  
  errorStatus(const errorStatus& from);
  
  inline errorStatus& operator=(const errorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const errorStatus& default_instance();
  
  void Swap(errorStatus* other);
  
  // implements Message ----------------------------------------------
  
  errorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const errorStatus& from);
  void MergeFrom(const errorStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:network_messages.errorStatus)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  ::google::protobuf::int32 code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static errorStatus* default_instance_;
};
// -------------------------------------------------------------------

class heartBeat : public ::google::protobuf::Message {
 public:
  heartBeat();
  virtual ~heartBeat();
  
  heartBeat(const heartBeat& from);
  
  inline heartBeat& operator=(const heartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const heartBeat& default_instance();
  
  void Swap(heartBeat* other);
  
  // implements Message ----------------------------------------------
  
  heartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const heartBeat& from);
  void MergeFrom(const heartBeat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // required string service_id = 2;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 2;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // required int32 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::int32 sequence() const;
  inline void set_sequence(::google::protobuf::int32 value);
  
  // optional int32 hfs_stat = 4;
  inline bool has_hfs_stat() const;
  inline void clear_hfs_stat();
  static const int kHfsStatFieldNumber = 4;
  inline ::google::protobuf::int32 hfs_stat() const;
  inline void set_hfs_stat(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:network_messages.heartBeat)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_hfs_stat();
  inline void clear_has_hfs_stat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  ::std::string* service_id_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 hfs_stat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static heartBeat* default_instance_;
};
// -------------------------------------------------------------------

class heartBeatAck : public ::google::protobuf::Message {
 public:
  heartBeatAck();
  virtual ~heartBeatAck();
  
  heartBeatAck(const heartBeatAck& from);
  
  inline heartBeatAck& operator=(const heartBeatAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const heartBeatAck& default_instance();
  
  void Swap(heartBeatAck* other);
  
  // implements Message ----------------------------------------------
  
  heartBeatAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const heartBeatAck& from);
  void MergeFrom(const heartBeatAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // required int32 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::int32 sequence() const;
  inline void set_sequence(::google::protobuf::int32 value);
  
  // optional int32 node_stat = 3;
  inline bool has_node_stat() const;
  inline void clear_node_stat();
  static const int kNodeStatFieldNumber = 3;
  inline ::google::protobuf::int32 node_stat() const;
  inline void set_node_stat(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:network_messages.heartBeatAck)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_node_stat();
  inline void clear_has_node_stat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 node_stat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static heartBeatAck* default_instance_;
};
// -------------------------------------------------------------------

class StopProxyAck : public ::google::protobuf::Message {
 public:
  StopProxyAck();
  virtual ~StopProxyAck();
  
  StopProxyAck(const StopProxyAck& from);
  
  inline StopProxyAck& operator=(const StopProxyAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopProxyAck& default_instance();
  
  void Swap(StopProxyAck* other);
  
  // implements Message ----------------------------------------------
  
  StopProxyAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopProxyAck& from);
  void MergeFrom(const StopProxyAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.errorStatus err = 1;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 1;
  inline const ::network_messages::errorStatus& err() const;
  inline ::network_messages::errorStatus* mutable_err();
  inline ::network_messages::errorStatus* release_err();
  
  // @@protoc_insertion_point(class_scope:network_messages.StopProxyAck)
 private:
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::errorStatus* err_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static StopProxyAck* default_instance_;
};
// -------------------------------------------------------------------

class BlockRequestAck : public ::google::protobuf::Message {
 public:
  BlockRequestAck();
  virtual ~BlockRequestAck();
  
  BlockRequestAck(const BlockRequestAck& from);
  
  inline BlockRequestAck& operator=(const BlockRequestAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockRequestAck& default_instance();
  
  void Swap(BlockRequestAck* other);
  
  // implements Message ----------------------------------------------
  
  BlockRequestAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockRequestAck& from);
  void MergeFrom(const BlockRequestAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.BlockRequestAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static BlockRequestAck* default_instance_;
};
// -------------------------------------------------------------------

class TransferComponentsAck_pair : public ::google::protobuf::Message {
 public:
  TransferComponentsAck_pair();
  virtual ~TransferComponentsAck_pair();
  
  TransferComponentsAck_pair(const TransferComponentsAck_pair& from);
  
  inline TransferComponentsAck_pair& operator=(const TransferComponentsAck_pair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferComponentsAck_pair& default_instance();
  
  void Swap(TransferComponentsAck_pair* other);
  
  // implements Message ----------------------------------------------
  
  TransferComponentsAck_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferComponentsAck_pair& from);
  void MergeFrom(const TransferComponentsAck_pair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 component = 1;
  inline bool has_component() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 1;
  inline ::google::protobuf::int32 component() const;
  inline void set_component(::google::protobuf::int32 value);
  
  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.TransferComponentsAck.pair)
 private:
  inline void set_has_component();
  inline void clear_has_component();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 component_;
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static TransferComponentsAck_pair* default_instance_;
};
// -------------------------------------------------------------------

class TransferComponentsAck : public ::google::protobuf::Message {
 public:
  TransferComponentsAck();
  virtual ~TransferComponentsAck();
  
  TransferComponentsAck(const TransferComponentsAck& from);
  
  inline TransferComponentsAck& operator=(const TransferComponentsAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferComponentsAck& default_instance();
  
  void Swap(TransferComponentsAck* other);
  
  // implements Message ----------------------------------------------
  
  TransferComponentsAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferComponentsAck& from);
  void MergeFrom(const TransferComponentsAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TransferComponentsAck_pair pair;
  
  // accessors -------------------------------------------------------
  
  // repeated .network_messages.TransferComponentsAck.pair comp_status_list = 2;
  inline int comp_status_list_size() const;
  inline void clear_comp_status_list();
  static const int kCompStatusListFieldNumber = 2;
  inline const ::network_messages::TransferComponentsAck_pair& comp_status_list(int index) const;
  inline ::network_messages::TransferComponentsAck_pair* mutable_comp_status_list(int index);
  inline ::network_messages::TransferComponentsAck_pair* add_comp_status_list();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComponentsAck_pair >&
      comp_status_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComponentsAck_pair >*
      mutable_comp_status_list();
  
  // required bool final_status = 3;
  inline bool has_final_status() const;
  inline void clear_final_status();
  static const int kFinalStatusFieldNumber = 3;
  inline bool final_status() const;
  inline void set_final_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.TransferComponentsAck)
 private:
  inline void set_has_final_status();
  inline void clear_has_final_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComponentsAck_pair > comp_status_list_;
  bool final_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static TransferComponentsAck* default_instance_;
};
// -------------------------------------------------------------------

class GetServiceComponentAck : public ::google::protobuf::Message {
 public:
  GetServiceComponentAck();
  virtual ~GetServiceComponentAck();
  
  GetServiceComponentAck(const GetServiceComponentAck& from);
  
  inline GetServiceComponentAck& operator=(const GetServiceComponentAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServiceComponentAck& default_instance();
  
  void Swap(GetServiceComponentAck* other);
  
  // implements Message ----------------------------------------------
  
  GetServiceComponentAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetServiceComponentAck& from);
  void MergeFrom(const GetServiceComponentAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 component_list = 1;
  inline int component_list_size() const;
  inline void clear_component_list();
  static const int kComponentListFieldNumber = 1;
  inline ::google::protobuf::int32 component_list(int index) const;
  inline void set_component_list(int index, ::google::protobuf::int32 value);
  inline void add_component_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      component_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_component_list();
  
  // required .network_messages.errorStatus err = 2;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 2;
  inline const ::network_messages::errorStatus& err() const;
  inline ::network_messages::errorStatus* mutable_err();
  inline ::network_messages::errorStatus* release_err();
  
  // @@protoc_insertion_point(class_scope:network_messages.GetServiceComponentAck)
 private:
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > component_list_;
  ::network_messages::errorStatus* err_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GetServiceComponentAck* default_instance_;
};
// -------------------------------------------------------------------

class GetServiceComponent : public ::google::protobuf::Message {
 public:
  GetServiceComponent();
  virtual ~GetServiceComponent();
  
  GetServiceComponent(const GetServiceComponent& from);
  
  inline GetServiceComponent& operator=(const GetServiceComponent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetServiceComponent& default_instance();
  
  void Swap(GetServiceComponent* other);
  
  // implements Message ----------------------------------------------
  
  GetServiceComponent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetServiceComponent& from);
  void MergeFrom(const GetServiceComponent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.GetServiceComponent)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GetServiceComponent* default_instance_;
};
// -------------------------------------------------------------------

class GetGlobalMap : public ::google::protobuf::Message {
 public:
  GetGlobalMap();
  virtual ~GetGlobalMap();
  
  GetGlobalMap(const GetGlobalMap& from);
  
  inline GetGlobalMap& operator=(const GetGlobalMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGlobalMap& default_instance();
  
  void Swap(GetGlobalMap* other);
  
  // implements Message ----------------------------------------------
  
  GetGlobalMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGlobalMap& from);
  void MergeFrom(const GetGlobalMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.GetGlobalMap)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GetGlobalMap* default_instance_;
};
// -------------------------------------------------------------------

class GlobalMapInfo_service : public ::google::protobuf::Message {
 public:
  GlobalMapInfo_service();
  virtual ~GlobalMapInfo_service();
  
  GlobalMapInfo_service(const GlobalMapInfo_service& from);
  
  inline GlobalMapInfo_service& operator=(const GlobalMapInfo_service& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalMapInfo_service& default_instance();
  
  void Swap(GlobalMapInfo_service* other);
  
  // implements Message ----------------------------------------------
  
  GlobalMapInfo_service* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalMapInfo_service& from);
  void MergeFrom(const GlobalMapInfo_service& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .network_messages.service_obj service_list = 1;
  inline int service_list_size() const;
  inline void clear_service_list();
  static const int kServiceListFieldNumber = 1;
  inline const ::network_messages::service_obj& service_list(int index) const;
  inline ::network_messages::service_obj* mutable_service_list(int index);
  inline ::network_messages::service_obj* add_service_list();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >&
      service_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >*
      mutable_service_list();
  
  // optional float version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline float version() const;
  inline void set_version(float value);
  
  // @@protoc_insertion_point(class_scope:network_messages.GlobalMapInfo.service)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj > service_list_;
  float version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GlobalMapInfo_service* default_instance_;
};
// -------------------------------------------------------------------

class GlobalMapInfo : public ::google::protobuf::Message {
 public:
  GlobalMapInfo();
  virtual ~GlobalMapInfo();
  
  GlobalMapInfo(const GlobalMapInfo& from);
  
  inline GlobalMapInfo& operator=(const GlobalMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalMapInfo& default_instance();
  
  void Swap(GlobalMapInfo* other);
  
  // implements Message ----------------------------------------------
  
  GlobalMapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalMapInfo& from);
  void MergeFrom(const GlobalMapInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GlobalMapInfo_service service;
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.GlobalMapInfo.service container = 1;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 1;
  inline const ::network_messages::GlobalMapInfo_service& container() const;
  inline ::network_messages::GlobalMapInfo_service* mutable_container();
  inline ::network_messages::GlobalMapInfo_service* release_container();
  
  // required .network_messages.GlobalMapInfo.service account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::network_messages::GlobalMapInfo_service& account() const;
  inline ::network_messages::GlobalMapInfo_service* mutable_account();
  inline ::network_messages::GlobalMapInfo_service* release_account();
  
  // required .network_messages.GlobalMapInfo.service updater = 3;
  inline bool has_updater() const;
  inline void clear_updater();
  static const int kUpdaterFieldNumber = 3;
  inline const ::network_messages::GlobalMapInfo_service& updater() const;
  inline ::network_messages::GlobalMapInfo_service* mutable_updater();
  inline ::network_messages::GlobalMapInfo_service* release_updater();
  
  // required .network_messages.GlobalMapInfo.service object = 4;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 4;
  inline const ::network_messages::GlobalMapInfo_service& object() const;
  inline ::network_messages::GlobalMapInfo_service* mutable_object();
  inline ::network_messages::GlobalMapInfo_service* release_object();
  
  // required float version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline float version() const;
  inline void set_version(float value);
  
  // required bool status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.GlobalMapInfo)
 private:
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_updater();
  inline void clear_has_updater();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::GlobalMapInfo_service* container_;
  ::network_messages::GlobalMapInfo_service* account_;
  ::network_messages::GlobalMapInfo_service* updater_;
  ::network_messages::GlobalMapInfo_service* object_;
  float version_;
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GlobalMapInfo* default_instance_;
};
// -------------------------------------------------------------------

class LocalLeaderStartMonitoring : public ::google::protobuf::Message {
 public:
  LocalLeaderStartMonitoring();
  virtual ~LocalLeaderStartMonitoring();
  
  LocalLeaderStartMonitoring(const LocalLeaderStartMonitoring& from);
  
  inline LocalLeaderStartMonitoring& operator=(const LocalLeaderStartMonitoring& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalLeaderStartMonitoring& default_instance();
  
  void Swap(LocalLeaderStartMonitoring* other);
  
  // implements Message ----------------------------------------------
  
  LocalLeaderStartMonitoring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalLeaderStartMonitoring& from);
  void MergeFrom(const LocalLeaderStartMonitoring& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.LocalLeaderStartMonitoring)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static LocalLeaderStartMonitoring* default_instance_;
};
// -------------------------------------------------------------------

class LocalLeaderStartMonitoringAck : public ::google::protobuf::Message {
 public:
  LocalLeaderStartMonitoringAck();
  virtual ~LocalLeaderStartMonitoringAck();
  
  LocalLeaderStartMonitoringAck(const LocalLeaderStartMonitoringAck& from);
  
  inline LocalLeaderStartMonitoringAck& operator=(const LocalLeaderStartMonitoringAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalLeaderStartMonitoringAck& default_instance();
  
  void Swap(LocalLeaderStartMonitoringAck* other);
  
  // implements Message ----------------------------------------------
  
  LocalLeaderStartMonitoringAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalLeaderStartMonitoringAck& from);
  void MergeFrom(const LocalLeaderStartMonitoringAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.LocalLeaderStartMonitoringAck)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static LocalLeaderStartMonitoringAck* default_instance_;
};
// -------------------------------------------------------------------

class OsdStartMonitoring : public ::google::protobuf::Message {
 public:
  OsdStartMonitoring();
  virtual ~OsdStartMonitoring();
  
  OsdStartMonitoring(const OsdStartMonitoring& from);
  
  inline OsdStartMonitoring& operator=(const OsdStartMonitoring& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsdStartMonitoring& default_instance();
  
  void Swap(OsdStartMonitoring* other);
  
  // implements Message ----------------------------------------------
  
  OsdStartMonitoring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsdStartMonitoring& from);
  void MergeFrom(const OsdStartMonitoring& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // required string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:network_messages.OsdStartMonitoring)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static OsdStartMonitoring* default_instance_;
};
// -------------------------------------------------------------------

class OsdStartMonitoringAck : public ::google::protobuf::Message {
 public:
  OsdStartMonitoringAck();
  virtual ~OsdStartMonitoringAck();
  
  OsdStartMonitoringAck(const OsdStartMonitoringAck& from);
  
  inline OsdStartMonitoringAck& operator=(const OsdStartMonitoringAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsdStartMonitoringAck& default_instance();
  
  void Swap(OsdStartMonitoringAck* other);
  
  // implements Message ----------------------------------------------
  
  OsdStartMonitoringAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsdStartMonitoringAck& from);
  void MergeFrom(const OsdStartMonitoringAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // required .network_messages.errorStatus error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::network_messages::errorStatus& error() const;
  inline ::network_messages::errorStatus* mutable_error();
  inline ::network_messages::errorStatus* release_error();
  
  // @@protoc_insertion_point(class_scope:network_messages.OsdStartMonitoringAck)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_error();
  inline void clear_has_error();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  ::network_messages::errorStatus* error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static OsdStartMonitoringAck* default_instance_;
};
// -------------------------------------------------------------------

class RecvProcStartMonitoring : public ::google::protobuf::Message {
 public:
  RecvProcStartMonitoring();
  virtual ~RecvProcStartMonitoring();
  
  RecvProcStartMonitoring(const RecvProcStartMonitoring& from);
  
  inline RecvProcStartMonitoring& operator=(const RecvProcStartMonitoring& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecvProcStartMonitoring& default_instance();
  
  void Swap(RecvProcStartMonitoring* other);
  
  // implements Message ----------------------------------------------
  
  RecvProcStartMonitoring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecvProcStartMonitoring& from);
  void MergeFrom(const RecvProcStartMonitoring& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string proc_id = 1;
  inline bool has_proc_id() const;
  inline void clear_proc_id();
  static const int kProcIdFieldNumber = 1;
  inline const ::std::string& proc_id() const;
  inline void set_proc_id(const ::std::string& value);
  inline void set_proc_id(const char* value);
  inline void set_proc_id(const char* value, size_t size);
  inline ::std::string* mutable_proc_id();
  inline ::std::string* release_proc_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.RecvProcStartMonitoring)
 private:
  inline void set_has_proc_id();
  inline void clear_has_proc_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* proc_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static RecvProcStartMonitoring* default_instance_;
};
// -------------------------------------------------------------------

class RecvProcStartMonitoringAck_entry : public ::google::protobuf::Message {
 public:
  RecvProcStartMonitoringAck_entry();
  virtual ~RecvProcStartMonitoringAck_entry();
  
  RecvProcStartMonitoringAck_entry(const RecvProcStartMonitoringAck_entry& from);
  
  inline RecvProcStartMonitoringAck_entry& operator=(const RecvProcStartMonitoringAck_entry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecvProcStartMonitoringAck_entry& default_instance();
  
  void Swap(RecvProcStartMonitoringAck_entry* other);
  
  // implements Message ----------------------------------------------
  
  RecvProcStartMonitoringAck_entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecvProcStartMonitoringAck_entry& from);
  void MergeFrom(const RecvProcStartMonitoringAck_entry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.service_obj service = 1;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 1;
  inline const ::network_messages::service_obj& service() const;
  inline ::network_messages::service_obj* mutable_service();
  inline ::network_messages::service_obj* release_service();
  
  // repeated int32 component_list = 2;
  inline int component_list_size() const;
  inline void clear_component_list();
  static const int kComponentListFieldNumber = 2;
  inline ::google::protobuf::int32 component_list(int index) const;
  inline void set_component_list(int index, ::google::protobuf::int32 value);
  inline void add_component_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      component_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_component_list();
  
  // @@protoc_insertion_point(class_scope:network_messages.RecvProcStartMonitoringAck.entry)
 private:
  inline void set_has_service();
  inline void clear_has_service();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::service_obj* service_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > component_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static RecvProcStartMonitoringAck_entry* default_instance_;
};
// -------------------------------------------------------------------

class RecvProcStartMonitoringAck : public ::google::protobuf::Message {
 public:
  RecvProcStartMonitoringAck();
  virtual ~RecvProcStartMonitoringAck();
  
  RecvProcStartMonitoringAck(const RecvProcStartMonitoringAck& from);
  
  inline RecvProcStartMonitoringAck& operator=(const RecvProcStartMonitoringAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecvProcStartMonitoringAck& default_instance();
  
  void Swap(RecvProcStartMonitoringAck* other);
  
  // implements Message ----------------------------------------------
  
  RecvProcStartMonitoringAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecvProcStartMonitoringAck& from);
  void MergeFrom(const RecvProcStartMonitoringAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef RecvProcStartMonitoringAck_entry entry;
  
  // accessors -------------------------------------------------------
  
  // repeated .network_messages.RecvProcStartMonitoringAck.entry service_name = 1;
  inline int service_name_size() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  inline const ::network_messages::RecvProcStartMonitoringAck_entry& service_name(int index) const;
  inline ::network_messages::RecvProcStartMonitoringAck_entry* mutable_service_name(int index);
  inline ::network_messages::RecvProcStartMonitoringAck_entry* add_service_name();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::RecvProcStartMonitoringAck_entry >&
      service_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::RecvProcStartMonitoringAck_entry >*
      mutable_service_name();
  
  // optional .network_messages.service_obj source_service = 2;
  inline bool has_source_service() const;
  inline void clear_source_service();
  static const int kSourceServiceFieldNumber = 2;
  inline const ::network_messages::service_obj& source_service() const;
  inline ::network_messages::service_obj* mutable_source_service();
  inline ::network_messages::service_obj* release_source_service();
  
  // required bool status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.RecvProcStartMonitoringAck)
 private:
  inline void set_has_source_service();
  inline void clear_has_source_service();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::network_messages::RecvProcStartMonitoringAck_entry > service_name_;
  ::network_messages::service_obj* source_service_;
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static RecvProcStartMonitoringAck* default_instance_;
};
// -------------------------------------------------------------------

class CompTransferInfo_pair : public ::google::protobuf::Message {
 public:
  CompTransferInfo_pair();
  virtual ~CompTransferInfo_pair();
  
  CompTransferInfo_pair(const CompTransferInfo_pair& from);
  
  inline CompTransferInfo_pair& operator=(const CompTransferInfo_pair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompTransferInfo_pair& default_instance();
  
  void Swap(CompTransferInfo_pair* other);
  
  // implements Message ----------------------------------------------
  
  CompTransferInfo_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompTransferInfo_pair& from);
  void MergeFrom(const CompTransferInfo_pair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 component = 1;
  inline bool has_component() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 1;
  inline ::google::protobuf::int32 component() const;
  inline void set_component(::google::protobuf::int32 value);
  
  // required .network_messages.service_obj dest_service = 2;
  inline bool has_dest_service() const;
  inline void clear_dest_service();
  static const int kDestServiceFieldNumber = 2;
  inline const ::network_messages::service_obj& dest_service() const;
  inline ::network_messages::service_obj* mutable_dest_service();
  inline ::network_messages::service_obj* release_dest_service();
  
  // @@protoc_insertion_point(class_scope:network_messages.CompTransferInfo.pair)
 private:
  inline void set_has_component();
  inline void clear_has_component();
  inline void set_has_dest_service();
  inline void clear_has_dest_service();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::service_obj* dest_service_;
  ::google::protobuf::int32 component_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static CompTransferInfo_pair* default_instance_;
};
// -------------------------------------------------------------------

class CompTransferInfo : public ::google::protobuf::Message {
 public:
  CompTransferInfo();
  virtual ~CompTransferInfo();
  
  CompTransferInfo(const CompTransferInfo& from);
  
  inline CompTransferInfo& operator=(const CompTransferInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompTransferInfo& default_instance();
  
  void Swap(CompTransferInfo* other);
  
  // implements Message ----------------------------------------------
  
  CompTransferInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompTransferInfo& from);
  void MergeFrom(const CompTransferInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CompTransferInfo_pair pair;
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // repeated .network_messages.CompTransferInfo.pair component_service_pair = 2;
  inline int component_service_pair_size() const;
  inline void clear_component_service_pair();
  static const int kComponentServicePairFieldNumber = 2;
  inline const ::network_messages::CompTransferInfo_pair& component_service_pair(int index) const;
  inline ::network_messages::CompTransferInfo_pair* mutable_component_service_pair(int index);
  inline ::network_messages::CompTransferInfo_pair* add_component_service_pair();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::CompTransferInfo_pair >&
      component_service_pair() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::CompTransferInfo_pair >*
      mutable_component_service_pair();
  
  // @@protoc_insertion_point(class_scope:network_messages.CompTransferInfo)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  ::google::protobuf::RepeatedPtrField< ::network_messages::CompTransferInfo_pair > component_service_pair_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static CompTransferInfo* default_instance_;
};
// -------------------------------------------------------------------

class CompTranferFinalStat_pair : public ::google::protobuf::Message {
 public:
  CompTranferFinalStat_pair();
  virtual ~CompTranferFinalStat_pair();
  
  CompTranferFinalStat_pair(const CompTranferFinalStat_pair& from);
  
  inline CompTranferFinalStat_pair& operator=(const CompTranferFinalStat_pair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompTranferFinalStat_pair& default_instance();
  
  void Swap(CompTranferFinalStat_pair* other);
  
  // implements Message ----------------------------------------------
  
  CompTranferFinalStat_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompTranferFinalStat_pair& from);
  void MergeFrom(const CompTranferFinalStat_pair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 component = 1;
  inline bool has_component() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 1;
  inline ::google::protobuf::int32 component() const;
  inline void set_component(::google::protobuf::int32 value);
  
  // required bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.CompTranferFinalStat.pair)
 private:
  inline void set_has_component();
  inline void clear_has_component();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 component_;
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static CompTranferFinalStat_pair* default_instance_;
};
// -------------------------------------------------------------------

class CompTranferFinalStat : public ::google::protobuf::Message {
 public:
  CompTranferFinalStat();
  virtual ~CompTranferFinalStat();
  
  CompTranferFinalStat(const CompTranferFinalStat& from);
  
  inline CompTranferFinalStat& operator=(const CompTranferFinalStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompTranferFinalStat& default_instance();
  
  void Swap(CompTranferFinalStat* other);
  
  // implements Message ----------------------------------------------
  
  CompTranferFinalStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CompTranferFinalStat& from);
  void MergeFrom(const CompTranferFinalStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CompTranferFinalStat_pair pair;
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // repeated .network_messages.CompTranferFinalStat.pair comp_status_list = 2;
  inline int comp_status_list_size() const;
  inline void clear_comp_status_list();
  static const int kCompStatusListFieldNumber = 2;
  inline const ::network_messages::CompTranferFinalStat_pair& comp_status_list(int index) const;
  inline ::network_messages::CompTranferFinalStat_pair* mutable_comp_status_list(int index);
  inline ::network_messages::CompTranferFinalStat_pair* add_comp_status_list();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::CompTranferFinalStat_pair >&
      comp_status_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::CompTranferFinalStat_pair >*
      mutable_comp_status_list();
  
  // required bool final_status = 3;
  inline bool has_final_status() const;
  inline void clear_final_status();
  static const int kFinalStatusFieldNumber = 3;
  inline bool final_status() const;
  inline void set_final_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.CompTranferFinalStat)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_final_status();
  inline void clear_has_final_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  ::google::protobuf::RepeatedPtrField< ::network_messages::CompTranferFinalStat_pair > comp_status_list_;
  bool final_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static CompTranferFinalStat* default_instance_;
};
// -------------------------------------------------------------------

class TransferComp_pair : public ::google::protobuf::Message {
 public:
  TransferComp_pair();
  virtual ~TransferComp_pair();
  
  TransferComp_pair(const TransferComp_pair& from);
  
  inline TransferComp_pair& operator=(const TransferComp_pair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferComp_pair& default_instance();
  
  void Swap(TransferComp_pair* other);
  
  // implements Message ----------------------------------------------
  
  TransferComp_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferComp_pair& from);
  void MergeFrom(const TransferComp_pair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.service_obj dest_service = 1;
  inline bool has_dest_service() const;
  inline void clear_dest_service();
  static const int kDestServiceFieldNumber = 1;
  inline const ::network_messages::service_obj& dest_service() const;
  inline ::network_messages::service_obj* mutable_dest_service();
  inline ::network_messages::service_obj* release_dest_service();
  
  // repeated int32 component = 2;
  inline int component_size() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 2;
  inline ::google::protobuf::int32 component(int index) const;
  inline void set_component(int index, ::google::protobuf::int32 value);
  inline void add_component(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      component() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_component();
  
  // @@protoc_insertion_point(class_scope:network_messages.TransferComp.pair)
 private:
  inline void set_has_dest_service();
  inline void clear_has_dest_service();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::service_obj* dest_service_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > component_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static TransferComp_pair* default_instance_;
};
// -------------------------------------------------------------------

class TransferComp : public ::google::protobuf::Message {
 public:
  TransferComp();
  virtual ~TransferComp();
  
  TransferComp(const TransferComp& from);
  
  inline TransferComp& operator=(const TransferComp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferComp& default_instance();
  
  void Swap(TransferComp* other);
  
  // implements Message ----------------------------------------------
  
  TransferComp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferComp& from);
  void MergeFrom(const TransferComp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TransferComp_pair pair;
  
  // accessors -------------------------------------------------------
  
  // repeated .network_messages.TransferComp.pair service_comp_list = 1;
  inline int service_comp_list_size() const;
  inline void clear_service_comp_list();
  static const int kServiceCompListFieldNumber = 1;
  inline const ::network_messages::TransferComp_pair& service_comp_list(int index) const;
  inline ::network_messages::TransferComp_pair* mutable_service_comp_list(int index);
  inline ::network_messages::TransferComp_pair* add_service_comp_list();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComp_pair >&
      service_comp_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComp_pair >*
      mutable_service_comp_list();
  
  // @@protoc_insertion_point(class_scope:network_messages.TransferComp)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComp_pair > service_comp_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static TransferComp* default_instance_;
};
// -------------------------------------------------------------------

class NodeAdditionCli : public ::google::protobuf::Message {
 public:
  NodeAdditionCli();
  virtual ~NodeAdditionCli();
  
  NodeAdditionCli(const NodeAdditionCli& from);
  
  inline NodeAdditionCli& operator=(const NodeAdditionCli& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeAdditionCli& default_instance();
  
  void Swap(NodeAdditionCli* other);
  
  // implements Message ----------------------------------------------
  
  NodeAdditionCli* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeAdditionCli& from);
  void MergeFrom(const NodeAdditionCli& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .network_messages.service_obj node_list = 1;
  inline int node_list_size() const;
  inline void clear_node_list();
  static const int kNodeListFieldNumber = 1;
  inline const ::network_messages::service_obj& node_list(int index) const;
  inline ::network_messages::service_obj* mutable_node_list(int index);
  inline ::network_messages::service_obj* add_node_list();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >&
      node_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >*
      mutable_node_list();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeAdditionCli)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj > node_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeAdditionCli* default_instance_;
};
// -------------------------------------------------------------------

class NodeAdditionCliAck_pair : public ::google::protobuf::Message {
 public:
  NodeAdditionCliAck_pair();
  virtual ~NodeAdditionCliAck_pair();
  
  NodeAdditionCliAck_pair(const NodeAdditionCliAck_pair& from);
  
  inline NodeAdditionCliAck_pair& operator=(const NodeAdditionCliAck_pair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeAdditionCliAck_pair& default_instance();
  
  void Swap(NodeAdditionCliAck_pair* other);
  
  // implements Message ----------------------------------------------
  
  NodeAdditionCliAck_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeAdditionCliAck_pair& from);
  void MergeFrom(const NodeAdditionCliAck_pair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.errorStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // required .network_messages.service_obj node = 2;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 2;
  inline const ::network_messages::service_obj& node() const;
  inline ::network_messages::service_obj* mutable_node();
  inline ::network_messages::service_obj* release_node();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeAdditionCliAck.pair)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_node();
  inline void clear_has_node();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::errorStatus* status_;
  ::network_messages::service_obj* node_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeAdditionCliAck_pair* default_instance_;
};
// -------------------------------------------------------------------

class NodeAdditionCliAck : public ::google::protobuf::Message {
 public:
  NodeAdditionCliAck();
  virtual ~NodeAdditionCliAck();
  
  NodeAdditionCliAck(const NodeAdditionCliAck& from);
  
  inline NodeAdditionCliAck& operator=(const NodeAdditionCliAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeAdditionCliAck& default_instance();
  
  void Swap(NodeAdditionCliAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeAdditionCliAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeAdditionCliAck& from);
  void MergeFrom(const NodeAdditionCliAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef NodeAdditionCliAck_pair pair;
  
  // accessors -------------------------------------------------------
  
  // repeated .network_messages.NodeAdditionCliAck.pair node_ack_list = 1;
  inline int node_ack_list_size() const;
  inline void clear_node_ack_list();
  static const int kNodeAckListFieldNumber = 1;
  inline const ::network_messages::NodeAdditionCliAck_pair& node_ack_list(int index) const;
  inline ::network_messages::NodeAdditionCliAck_pair* mutable_node_ack_list(int index);
  inline ::network_messages::NodeAdditionCliAck_pair* add_node_ack_list();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::NodeAdditionCliAck_pair >&
      node_ack_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::NodeAdditionCliAck_pair >*
      mutable_node_ack_list();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeAdditionCliAck)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::network_messages::NodeAdditionCliAck_pair > node_ack_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeAdditionCliAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeAdditionGl : public ::google::protobuf::Message {
 public:
  NodeAdditionGl();
  virtual ~NodeAdditionGl();
  
  NodeAdditionGl(const NodeAdditionGl& from);
  
  inline NodeAdditionGl& operator=(const NodeAdditionGl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeAdditionGl& default_instance();
  
  void Swap(NodeAdditionGl* other);
  
  // implements Message ----------------------------------------------
  
  NodeAdditionGl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeAdditionGl& from);
  void MergeFrom(const NodeAdditionGl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeAdditionGl)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeAdditionGl* default_instance_;
};
// -------------------------------------------------------------------

class NodeAdditionGlAck : public ::google::protobuf::Message {
 public:
  NodeAdditionGlAck();
  virtual ~NodeAdditionGlAck();
  
  NodeAdditionGlAck(const NodeAdditionGlAck& from);
  
  inline NodeAdditionGlAck& operator=(const NodeAdditionGlAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeAdditionGlAck& default_instance();
  
  void Swap(NodeAdditionGlAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeAdditionGlAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeAdditionGlAck& from);
  void MergeFrom(const NodeAdditionGlAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.errorStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // repeated .network_messages.service_obj service_list = 2;
  inline int service_list_size() const;
  inline void clear_service_list();
  static const int kServiceListFieldNumber = 2;
  inline const ::network_messages::service_obj& service_list(int index) const;
  inline ::network_messages::service_obj* mutable_service_list(int index);
  inline ::network_messages::service_obj* add_service_list();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >&
      service_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >*
      mutable_service_list();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeAdditionGlAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::errorStatus* status_;
  ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj > service_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeAdditionGlAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeStopLL : public ::google::protobuf::Message {
 public:
  NodeStopLL();
  virtual ~NodeStopLL();
  
  NodeStopLL(const NodeStopLL& from);
  
  inline NodeStopLL& operator=(const NodeStopLL& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStopLL& default_instance();
  
  void Swap(NodeStopLL* other);
  
  // implements Message ----------------------------------------------
  
  NodeStopLL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeStopLL& from);
  void MergeFrom(const NodeStopLL& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.service_obj node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::network_messages::service_obj& node() const;
  inline ::network_messages::service_obj* mutable_node();
  inline ::network_messages::service_obj* release_node();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeStopLL)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::service_obj* node_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeStopLL* default_instance_;
};
// -------------------------------------------------------------------

class NodeStopLLAck : public ::google::protobuf::Message {
 public:
  NodeStopLLAck();
  virtual ~NodeStopLLAck();
  
  NodeStopLLAck(const NodeStopLLAck& from);
  
  inline NodeStopLLAck& operator=(const NodeStopLLAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStopLLAck& default_instance();
  
  void Swap(NodeStopLLAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeStopLLAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeStopLLAck& from);
  void MergeFrom(const NodeStopLLAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // required .network_messages.errorStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // required int32 node_status = 3;
  inline bool has_node_status() const;
  inline void clear_node_status();
  static const int kNodeStatusFieldNumber = 3;
  inline ::google::protobuf::int32 node_status() const;
  inline void set_node_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeStopLLAck)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_node_status();
  inline void clear_has_node_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  ::network_messages::errorStatus* status_;
  ::google::protobuf::int32 node_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeStopLLAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeRetire : public ::google::protobuf::Message {
 public:
  NodeRetire();
  virtual ~NodeRetire();
  
  NodeRetire(const NodeRetire& from);
  
  inline NodeRetire& operator=(const NodeRetire& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeRetire& default_instance();
  
  void Swap(NodeRetire* other);
  
  // implements Message ----------------------------------------------
  
  NodeRetire* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeRetire& from);
  void MergeFrom(const NodeRetire& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.service_obj node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::network_messages::service_obj& node() const;
  inline ::network_messages::service_obj* mutable_node();
  inline ::network_messages::service_obj* release_node();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeRetire)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::service_obj* node_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeRetire* default_instance_;
};
// -------------------------------------------------------------------

class NodeRetireAck : public ::google::protobuf::Message {
 public:
  NodeRetireAck();
  virtual ~NodeRetireAck();
  
  NodeRetireAck(const NodeRetireAck& from);
  
  inline NodeRetireAck& operator=(const NodeRetireAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeRetireAck& default_instance();
  
  void Swap(NodeRetireAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeRetireAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeRetireAck& from);
  void MergeFrom(const NodeRetireAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // required .network_messages.errorStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeRetireAck)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeRetireAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeDeletionCli : public ::google::protobuf::Message {
 public:
  NodeDeletionCli();
  virtual ~NodeDeletionCli();
  
  NodeDeletionCli(const NodeDeletionCli& from);
  
  inline NodeDeletionCli& operator=(const NodeDeletionCli& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeDeletionCli& default_instance();
  
  void Swap(NodeDeletionCli* other);
  
  // implements Message ----------------------------------------------
  
  NodeDeletionCli* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeDeletionCli& from);
  void MergeFrom(const NodeDeletionCli& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.service_obj node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::network_messages::service_obj& node() const;
  inline ::network_messages::service_obj* mutable_node();
  inline ::network_messages::service_obj* release_node();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeDeletionCli)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::service_obj* node_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeDeletionCli* default_instance_;
};
// -------------------------------------------------------------------

class NodeDeletionCliAck : public ::google::protobuf::Message {
 public:
  NodeDeletionCliAck();
  virtual ~NodeDeletionCliAck();
  
  NodeDeletionCliAck(const NodeDeletionCliAck& from);
  
  inline NodeDeletionCliAck& operator=(const NodeDeletionCliAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeDeletionCliAck& default_instance();
  
  void Swap(NodeDeletionCliAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeDeletionCliAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeDeletionCliAck& from);
  void MergeFrom(const NodeDeletionCliAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // required .network_messages.errorStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeDeletionCliAck)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeDeletionCliAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeSystemStopCli : public ::google::protobuf::Message {
 public:
  NodeSystemStopCli();
  virtual ~NodeSystemStopCli();
  
  NodeSystemStopCli(const NodeSystemStopCli& from);
  
  inline NodeSystemStopCli& operator=(const NodeSystemStopCli& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeSystemStopCli& default_instance();
  
  void Swap(NodeSystemStopCli* other);
  
  // implements Message ----------------------------------------------
  
  NodeSystemStopCli* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeSystemStopCli& from);
  void MergeFrom(const NodeSystemStopCli& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeSystemStopCli)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeSystemStopCli* default_instance_;
};
// -------------------------------------------------------------------

class LocalNodeStatus : public ::google::protobuf::Message {
 public:
  LocalNodeStatus();
  virtual ~LocalNodeStatus();
  
  LocalNodeStatus(const LocalNodeStatus& from);
  
  inline LocalNodeStatus& operator=(const LocalNodeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalNodeStatus& default_instance();
  
  void Swap(LocalNodeStatus* other);
  
  // implements Message ----------------------------------------------
  
  LocalNodeStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalNodeStatus& from);
  void MergeFrom(const LocalNodeStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.LocalNodeStatus)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static LocalNodeStatus* default_instance_;
};
// -------------------------------------------------------------------

class NodeStatus : public ::google::protobuf::Message {
 public:
  NodeStatus();
  virtual ~NodeStatus();
  
  NodeStatus(const NodeStatus& from);
  
  inline NodeStatus& operator=(const NodeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStatus& default_instance();
  
  void Swap(NodeStatus* other);
  
  // implements Message ----------------------------------------------
  
  NodeStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeStatus& from);
  void MergeFrom(const NodeStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.service_obj node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::network_messages::service_obj& node() const;
  inline ::network_messages::service_obj* mutable_node();
  inline ::network_messages::service_obj* release_node();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeStatus)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::service_obj* node_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeStatus* default_instance_;
};
// -------------------------------------------------------------------

class NodeStatusAck : public ::google::protobuf::Message {
 public:
  NodeStatusAck();
  virtual ~NodeStatusAck();
  
  NodeStatusAck(const NodeStatusAck& from);
  
  inline NodeStatusAck& operator=(const NodeStatusAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStatusAck& default_instance();
  
  void Swap(NodeStatusAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeStatusAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeStatusAck& from);
  void MergeFrom(const NodeStatusAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.NodeStatusEnum status = 1 [default = INVALID_NODE];
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline network_messages::NodeStatusEnum status() const;
  inline void set_status(network_messages::NodeStatusEnum value);
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeStatusAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeStatusAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeStopCli : public ::google::protobuf::Message {
 public:
  NodeStopCli();
  virtual ~NodeStopCli();
  
  NodeStopCli(const NodeStopCli& from);
  
  inline NodeStopCli& operator=(const NodeStopCli& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStopCli& default_instance();
  
  void Swap(NodeStopCli* other);
  
  // implements Message ----------------------------------------------
  
  NodeStopCli* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeStopCli& from);
  void MergeFrom(const NodeStopCli& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeStopCli)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeStopCli* default_instance_;
};
// -------------------------------------------------------------------

class NodeStopCliAck : public ::google::protobuf::Message {
 public:
  NodeStopCliAck();
  virtual ~NodeStopCliAck();
  
  NodeStopCliAck(const NodeStopCliAck& from);
  
  inline NodeStopCliAck& operator=(const NodeStopCliAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeStopCliAck& default_instance();
  
  void Swap(NodeStopCliAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeStopCliAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeStopCliAck& from);
  void MergeFrom(const NodeStopCliAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.errorStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeStopCliAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeStopCliAck* default_instance_;
};
// -------------------------------------------------------------------

class StopServices : public ::google::protobuf::Message {
 public:
  StopServices();
  virtual ~StopServices();
  
  StopServices(const StopServices& from);
  
  inline StopServices& operator=(const StopServices& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopServices& default_instance();
  
  void Swap(StopServices* other);
  
  // implements Message ----------------------------------------------
  
  StopServices* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopServices& from);
  void MergeFrom(const StopServices& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.StopServices)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static StopServices* default_instance_;
};
// -------------------------------------------------------------------

class StopServicesAck : public ::google::protobuf::Message {
 public:
  StopServicesAck();
  virtual ~StopServicesAck();
  
  StopServicesAck(const StopServicesAck& from);
  
  inline StopServicesAck& operator=(const StopServicesAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopServicesAck& default_instance();
  
  void Swap(StopServicesAck* other);
  
  // implements Message ----------------------------------------------
  
  StopServicesAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopServicesAck& from);
  void MergeFrom(const StopServicesAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.errorStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.StopServicesAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static StopServicesAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeFailover : public ::google::protobuf::Message {
 public:
  NodeFailover();
  virtual ~NodeFailover();
  
  NodeFailover(const NodeFailover& from);
  
  inline NodeFailover& operator=(const NodeFailover& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeFailover& default_instance();
  
  void Swap(NodeFailover* other);
  
  // implements Message ----------------------------------------------
  
  NodeFailover* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeFailover& from);
  void MergeFrom(const NodeFailover& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // required .network_messages.errorStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeFailover)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeFailover* default_instance_;
};
// -------------------------------------------------------------------

class NodeFailoverAck : public ::google::protobuf::Message {
 public:
  NodeFailoverAck();
  virtual ~NodeFailoverAck();
  
  NodeFailoverAck(const NodeFailoverAck& from);
  
  inline NodeFailoverAck& operator=(const NodeFailoverAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeFailoverAck& default_instance();
  
  void Swap(NodeFailoverAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeFailoverAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeFailoverAck& from);
  void MergeFrom(const NodeFailoverAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .network_messages.errorStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeFailoverAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeFailoverAck* default_instance_;
};
// -------------------------------------------------------------------

class TakeGlOwnership : public ::google::protobuf::Message {
 public:
  TakeGlOwnership();
  virtual ~TakeGlOwnership();
  
  TakeGlOwnership(const TakeGlOwnership& from);
  
  inline TakeGlOwnership& operator=(const TakeGlOwnership& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TakeGlOwnership& default_instance();
  
  void Swap(TakeGlOwnership* other);
  
  // implements Message ----------------------------------------------
  
  TakeGlOwnership* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TakeGlOwnership& from);
  void MergeFrom(const TakeGlOwnership& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string old_gl_id = 1;
  inline bool has_old_gl_id() const;
  inline void clear_old_gl_id();
  static const int kOldGlIdFieldNumber = 1;
  inline const ::std::string& old_gl_id() const;
  inline void set_old_gl_id(const ::std::string& value);
  inline void set_old_gl_id(const char* value);
  inline void set_old_gl_id(const char* value, size_t size);
  inline ::std::string* mutable_old_gl_id();
  inline ::std::string* release_old_gl_id();
  
  // required string new_gl_id = 2;
  inline bool has_new_gl_id() const;
  inline void clear_new_gl_id();
  static const int kNewGlIdFieldNumber = 2;
  inline const ::std::string& new_gl_id() const;
  inline void set_new_gl_id(const ::std::string& value);
  inline void set_new_gl_id(const char* value);
  inline void set_new_gl_id(const char* value, size_t size);
  inline ::std::string* mutable_new_gl_id();
  inline ::std::string* release_new_gl_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.TakeGlOwnership)
 private:
  inline void set_has_old_gl_id();
  inline void clear_has_old_gl_id();
  inline void set_has_new_gl_id();
  inline void clear_has_new_gl_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* old_gl_id_;
  ::std::string* new_gl_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static TakeGlOwnership* default_instance_;
};
// -------------------------------------------------------------------

class TakeGlOwnershipAck : public ::google::protobuf::Message {
 public:
  TakeGlOwnershipAck();
  virtual ~TakeGlOwnershipAck();
  
  TakeGlOwnershipAck(const TakeGlOwnershipAck& from);
  
  inline TakeGlOwnershipAck& operator=(const TakeGlOwnershipAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TakeGlOwnershipAck& default_instance();
  
  void Swap(TakeGlOwnershipAck* other);
  
  // implements Message ----------------------------------------------
  
  TakeGlOwnershipAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TakeGlOwnershipAck& from);
  void MergeFrom(const TakeGlOwnershipAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string new_gl_id = 1;
  inline bool has_new_gl_id() const;
  inline void clear_new_gl_id();
  static const int kNewGlIdFieldNumber = 1;
  inline const ::std::string& new_gl_id() const;
  inline void set_new_gl_id(const ::std::string& value);
  inline void set_new_gl_id(const char* value);
  inline void set_new_gl_id(const char* value, size_t size);
  inline ::std::string* mutable_new_gl_id();
  inline ::std::string* release_new_gl_id();
  
  // required .network_messages.errorStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.TakeGlOwnershipAck)
 private:
  inline void set_has_new_gl_id();
  inline void clear_has_new_gl_id();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* new_gl_id_;
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static TakeGlOwnershipAck* default_instance_;
};
// -------------------------------------------------------------------

class GetObjectVersion : public ::google::protobuf::Message {
 public:
  GetObjectVersion();
  virtual ~GetObjectVersion();
  
  GetObjectVersion(const GetObjectVersion& from);
  
  inline GetObjectVersion& operator=(const GetObjectVersion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetObjectVersion& default_instance();
  
  void Swap(GetObjectVersion* other);
  
  // implements Message ----------------------------------------------
  
  GetObjectVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetObjectVersion& from);
  void MergeFrom(const GetObjectVersion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.GetObjectVersion)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GetObjectVersion* default_instance_;
};
// -------------------------------------------------------------------

class GetObjectVersionAck : public ::google::protobuf::Message {
 public:
  GetObjectVersionAck();
  virtual ~GetObjectVersionAck();
  
  GetObjectVersionAck(const GetObjectVersionAck& from);
  
  inline GetObjectVersionAck& operator=(const GetObjectVersionAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetObjectVersionAck& default_instance();
  
  void Swap(GetObjectVersionAck* other);
  
  // implements Message ----------------------------------------------
  
  GetObjectVersionAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetObjectVersionAck& from);
  void MergeFrom(const GetObjectVersionAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // required uint64 object_version = 2;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);
  
  // required bool status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.GetObjectVersionAck)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_object_version();
  inline void clear_has_object_version();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  ::google::protobuf::uint64 object_version_;
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GetObjectVersionAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeRejoinAfterRecovery : public ::google::protobuf::Message {
 public:
  NodeRejoinAfterRecovery();
  virtual ~NodeRejoinAfterRecovery();
  
  NodeRejoinAfterRecovery(const NodeRejoinAfterRecovery& from);
  
  inline NodeRejoinAfterRecovery& operator=(const NodeRejoinAfterRecovery& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeRejoinAfterRecovery& default_instance();
  
  void Swap(NodeRejoinAfterRecovery* other);
  
  // implements Message ----------------------------------------------
  
  NodeRejoinAfterRecovery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeRejoinAfterRecovery& from);
  void MergeFrom(const NodeRejoinAfterRecovery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // required string node_ip = 2;
  inline bool has_node_ip() const;
  inline void clear_node_ip();
  static const int kNodeIpFieldNumber = 2;
  inline const ::std::string& node_ip() const;
  inline void set_node_ip(const ::std::string& value);
  inline void set_node_ip(const char* value);
  inline void set_node_ip(const char* value, size_t size);
  inline ::std::string* mutable_node_ip();
  inline ::std::string* release_node_ip();
  
  // required int32 node_port = 3;
  inline bool has_node_port() const;
  inline void clear_node_port();
  static const int kNodePortFieldNumber = 3;
  inline ::google::protobuf::int32 node_port() const;
  inline void set_node_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeRejoinAfterRecovery)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_node_ip();
  inline void clear_has_node_ip();
  inline void set_has_node_port();
  inline void clear_has_node_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  ::std::string* node_ip_;
  ::google::protobuf::int32 node_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeRejoinAfterRecovery* default_instance_;
};
// -------------------------------------------------------------------

class NodeRejoinAfterRecoveryAck : public ::google::protobuf::Message {
 public:
  NodeRejoinAfterRecoveryAck();
  virtual ~NodeRejoinAfterRecoveryAck();
  
  NodeRejoinAfterRecoveryAck(const NodeRejoinAfterRecoveryAck& from);
  
  inline NodeRejoinAfterRecoveryAck& operator=(const NodeRejoinAfterRecoveryAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeRejoinAfterRecoveryAck& default_instance();
  
  void Swap(NodeRejoinAfterRecoveryAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeRejoinAfterRecoveryAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeRejoinAfterRecoveryAck& from);
  void MergeFrom(const NodeRejoinAfterRecoveryAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // required .network_messages.errorStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeRejoinAfterRecoveryAck)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeRejoinAfterRecoveryAck* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterStatus : public ::google::protobuf::Message {
 public:
  GetClusterStatus();
  virtual ~GetClusterStatus();
  
  GetClusterStatus(const GetClusterStatus& from);
  
  inline GetClusterStatus& operator=(const GetClusterStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterStatus& default_instance();
  
  void Swap(GetClusterStatus* other);
  
  // implements Message ----------------------------------------------
  
  GetClusterStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterStatus& from);
  void MergeFrom(const GetClusterStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  
  // @@protoc_insertion_point(class_scope:network_messages.GetClusterStatus)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* service_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GetClusterStatus* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterStatusAck_pair : public ::google::protobuf::Message {
 public:
  GetClusterStatusAck_pair();
  virtual ~GetClusterStatusAck_pair();
  
  GetClusterStatusAck_pair(const GetClusterStatusAck_pair& from);
  
  inline GetClusterStatusAck_pair& operator=(const GetClusterStatusAck_pair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterStatusAck_pair& default_instance();
  
  void Swap(GetClusterStatusAck_pair* other);
  
  // implements Message ----------------------------------------------
  
  GetClusterStatusAck_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterStatusAck_pair& from);
  void MergeFrom(const GetClusterStatusAck_pair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  
  // required .network_messages.NodeStatusEnum status_enum = 2;
  inline bool has_status_enum() const;
  inline void clear_status_enum();
  static const int kStatusEnumFieldNumber = 2;
  inline network_messages::NodeStatusEnum status_enum() const;
  inline void set_status_enum(network_messages::NodeStatusEnum value);
  
  // @@protoc_insertion_point(class_scope:network_messages.GetClusterStatusAck.pair)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_status_enum();
  inline void clear_has_status_enum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_id_;
  int status_enum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GetClusterStatusAck_pair* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterStatusAck : public ::google::protobuf::Message {
 public:
  GetClusterStatusAck();
  virtual ~GetClusterStatusAck();
  
  GetClusterStatusAck(const GetClusterStatusAck& from);
  
  inline GetClusterStatusAck& operator=(const GetClusterStatusAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterStatusAck& default_instance();
  
  void Swap(GetClusterStatusAck* other);
  
  // implements Message ----------------------------------------------
  
  GetClusterStatusAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterStatusAck& from);
  void MergeFrom(const GetClusterStatusAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GetClusterStatusAck_pair pair;
  
  // accessors -------------------------------------------------------
  
  // repeated .network_messages.GetClusterStatusAck.pair node_status_list = 1;
  inline int node_status_list_size() const;
  inline void clear_node_status_list();
  static const int kNodeStatusListFieldNumber = 1;
  inline const ::network_messages::GetClusterStatusAck_pair& node_status_list(int index) const;
  inline ::network_messages::GetClusterStatusAck_pair* mutable_node_status_list(int index);
  inline ::network_messages::GetClusterStatusAck_pair* add_node_status_list();
  inline const ::google::protobuf::RepeatedPtrField< ::network_messages::GetClusterStatusAck_pair >&
      node_status_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::network_messages::GetClusterStatusAck_pair >*
      mutable_node_status_list();
  
  // required .network_messages.errorStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::network_messages::errorStatus& status() const;
  inline ::network_messages::errorStatus* mutable_status();
  inline ::network_messages::errorStatus* release_status();
  
  // @@protoc_insertion_point(class_scope:network_messages.GetClusterStatusAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::network_messages::GetClusterStatusAck_pair > node_status_list_;
  ::network_messages::errorStatus* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static GetClusterStatusAck* default_instance_;
};
// -------------------------------------------------------------------

class UpdateContainer : public ::google::protobuf::Message {
 public:
  UpdateContainer();
  virtual ~UpdateContainer();
  
  UpdateContainer(const UpdateContainer& from);
  
  inline UpdateContainer& operator=(const UpdateContainer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateContainer& default_instance();
  
  void Swap(UpdateContainer* other);
  
  // implements Message ----------------------------------------------
  
  UpdateContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateContainer& from);
  void MergeFrom(const UpdateContainer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string meta_file_path = 1;
  inline bool has_meta_file_path() const;
  inline void clear_meta_file_path();
  static const int kMetaFilePathFieldNumber = 1;
  inline const ::std::string& meta_file_path() const;
  inline void set_meta_file_path(const ::std::string& value);
  inline void set_meta_file_path(const char* value);
  inline void set_meta_file_path(const char* value, size_t size);
  inline ::std::string* mutable_meta_file_path();
  inline ::std::string* release_meta_file_path();
  
  // required string operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline const ::std::string& operation() const;
  inline void set_operation(const ::std::string& value);
  inline void set_operation(const char* value);
  inline void set_operation(const char* value, size_t size);
  inline ::std::string* mutable_operation();
  inline ::std::string* release_operation();
  
  // @@protoc_insertion_point(class_scope:network_messages.UpdateContainer)
 private:
  inline void set_has_meta_file_path();
  inline void clear_has_meta_file_path();
  inline void set_has_operation();
  inline void clear_has_operation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* meta_file_path_;
  ::std::string* operation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateContainer* default_instance_;
};
// -------------------------------------------------------------------

class ReleaseTransactionLock : public ::google::protobuf::Message {
 public:
  ReleaseTransactionLock();
  virtual ~ReleaseTransactionLock();
  
  ReleaseTransactionLock(const ReleaseTransactionLock& from);
  
  inline ReleaseTransactionLock& operator=(const ReleaseTransactionLock& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseTransactionLock& default_instance();
  
  void Swap(ReleaseTransactionLock* other);
  
  // implements Message ----------------------------------------------
  
  ReleaseTransactionLock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReleaseTransactionLock& from);
  void MergeFrom(const ReleaseTransactionLock& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string lock = 1;
  inline bool has_lock() const;
  inline void clear_lock();
  static const int kLockFieldNumber = 1;
  inline const ::std::string& lock() const;
  inline void set_lock(const ::std::string& value);
  inline void set_lock(const char* value);
  inline void set_lock(const char* value, size_t size);
  inline ::std::string* mutable_lock();
  inline ::std::string* release_lock();
  
  // required string operation = 2;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline const ::std::string& operation() const;
  inline void set_operation(const ::std::string& value);
  inline void set_operation(const char* value);
  inline void set_operation(const char* value, size_t size);
  inline ::std::string* mutable_operation();
  inline ::std::string* release_operation();
  
  // @@protoc_insertion_point(class_scope:network_messages.ReleaseTransactionLock)
 private:
  inline void set_has_lock();
  inline void clear_has_lock();
  inline void set_has_operation();
  inline void clear_has_operation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* lock_;
  ::std::string* operation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static ReleaseTransactionLock* default_instance_;
};
// -------------------------------------------------------------------

class StatusAck : public ::google::protobuf::Message {
 public:
  StatusAck();
  virtual ~StatusAck();
  
  StatusAck(const StatusAck& from);
  
  inline StatusAck& operator=(const StatusAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusAck& default_instance();
  
  void Swap(StatusAck* other);
  
  // implements Message ----------------------------------------------
  
  StatusAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusAck& from);
  void MergeFrom(const StatusAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.StatusAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static StatusAck* default_instance_;
};
// -------------------------------------------------------------------

class NodeAdditionFinalAck : public ::google::protobuf::Message {
 public:
  NodeAdditionFinalAck();
  virtual ~NodeAdditionFinalAck();
  
  NodeAdditionFinalAck(const NodeAdditionFinalAck& from);
  
  inline NodeAdditionFinalAck& operator=(const NodeAdditionFinalAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeAdditionFinalAck& default_instance();
  
  void Swap(NodeAdditionFinalAck* other);
  
  // implements Message ----------------------------------------------
  
  NodeAdditionFinalAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeAdditionFinalAck& from);
  void MergeFrom(const NodeAdditionFinalAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:network_messages.NodeAdditionFinalAck)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_AssignDesc_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  friend void protobuf_ShutdownFile_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto();
  
  void InitAsDefaultInstance();
  static NodeAdditionFinalAck* default_instance_;
};
// ===================================================================


// ===================================================================

// service_obj

// optional string service_id = 1;
inline bool service_obj::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void service_obj::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void service_obj::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void service_obj::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& service_obj::service_id() const {
  return *service_id_;
}
inline void service_obj::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void service_obj::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void service_obj::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* service_obj::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* service_obj::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ip = 2;
inline bool service_obj::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void service_obj::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void service_obj::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void service_obj::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& service_obj::ip() const {
  return *ip_;
}
inline void service_obj::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void service_obj::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void service_obj::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* service_obj::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* service_obj::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 port = 3;
inline bool service_obj::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void service_obj::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void service_obj::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void service_obj::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 service_obj::port() const {
  return port_;
}
inline void service_obj::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// errorStatus

// required int32 code = 1;
inline bool errorStatus::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void errorStatus::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void errorStatus::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void errorStatus::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 errorStatus::code() const {
  return code_;
}
inline void errorStatus::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required string msg = 2;
inline bool errorStatus::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void errorStatus::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void errorStatus::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void errorStatus::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& errorStatus::msg() const {
  return *msg_;
}
inline void errorStatus::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void errorStatus::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void errorStatus::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* errorStatus::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* errorStatus::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// heartBeat

// required string msg = 1;
inline bool heartBeat::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void heartBeat::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void heartBeat::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void heartBeat::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& heartBeat::msg() const {
  return *msg_;
}
inline void heartBeat::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void heartBeat::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void heartBeat::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* heartBeat::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* heartBeat::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string service_id = 2;
inline bool heartBeat::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void heartBeat::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void heartBeat::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void heartBeat::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& heartBeat::service_id() const {
  return *service_id_;
}
inline void heartBeat::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void heartBeat::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void heartBeat::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* heartBeat::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* heartBeat::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 sequence = 3;
inline bool heartBeat::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void heartBeat::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void heartBeat::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void heartBeat::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 heartBeat::sequence() const {
  return sequence_;
}
inline void heartBeat::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int32 hfs_stat = 4;
inline bool heartBeat::has_hfs_stat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void heartBeat::set_has_hfs_stat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void heartBeat::clear_has_hfs_stat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void heartBeat::clear_hfs_stat() {
  hfs_stat_ = 0;
  clear_has_hfs_stat();
}
inline ::google::protobuf::int32 heartBeat::hfs_stat() const {
  return hfs_stat_;
}
inline void heartBeat::set_hfs_stat(::google::protobuf::int32 value) {
  set_has_hfs_stat();
  hfs_stat_ = value;
}

// -------------------------------------------------------------------

// heartBeatAck

// required string msg = 1;
inline bool heartBeatAck::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void heartBeatAck::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void heartBeatAck::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void heartBeatAck::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& heartBeatAck::msg() const {
  return *msg_;
}
inline void heartBeatAck::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void heartBeatAck::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void heartBeatAck::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* heartBeatAck::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* heartBeatAck::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 sequence = 2;
inline bool heartBeatAck::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void heartBeatAck::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void heartBeatAck::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void heartBeatAck::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 heartBeatAck::sequence() const {
  return sequence_;
}
inline void heartBeatAck::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int32 node_stat = 3;
inline bool heartBeatAck::has_node_stat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void heartBeatAck::set_has_node_stat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void heartBeatAck::clear_has_node_stat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void heartBeatAck::clear_node_stat() {
  node_stat_ = 0;
  clear_has_node_stat();
}
inline ::google::protobuf::int32 heartBeatAck::node_stat() const {
  return node_stat_;
}
inline void heartBeatAck::set_node_stat(::google::protobuf::int32 value) {
  set_has_node_stat();
  node_stat_ = value;
}

// -------------------------------------------------------------------

// StopProxyAck

// required .network_messages.errorStatus err = 1;
inline bool StopProxyAck::has_err() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopProxyAck::set_has_err() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopProxyAck::clear_has_err() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopProxyAck::clear_err() {
  if (err_ != NULL) err_->::network_messages::errorStatus::Clear();
  clear_has_err();
}
inline const ::network_messages::errorStatus& StopProxyAck::err() const {
  return err_ != NULL ? *err_ : *default_instance_->err_;
}
inline ::network_messages::errorStatus* StopProxyAck::mutable_err() {
  set_has_err();
  if (err_ == NULL) err_ = new ::network_messages::errorStatus;
  return err_;
}
inline ::network_messages::errorStatus* StopProxyAck::release_err() {
  clear_has_err();
  ::network_messages::errorStatus* temp = err_;
  err_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// BlockRequestAck

// required bool status = 1;
inline bool BlockRequestAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockRequestAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockRequestAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockRequestAck::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool BlockRequestAck::status() const {
  return status_;
}
inline void BlockRequestAck::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// TransferComponentsAck_pair

// required int32 component = 1;
inline bool TransferComponentsAck_pair::has_component() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferComponentsAck_pair::set_has_component() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferComponentsAck_pair::clear_has_component() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferComponentsAck_pair::clear_component() {
  component_ = 0;
  clear_has_component();
}
inline ::google::protobuf::int32 TransferComponentsAck_pair::component() const {
  return component_;
}
inline void TransferComponentsAck_pair::set_component(::google::protobuf::int32 value) {
  set_has_component();
  component_ = value;
}

// required bool status = 2;
inline bool TransferComponentsAck_pair::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferComponentsAck_pair::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferComponentsAck_pair::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferComponentsAck_pair::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool TransferComponentsAck_pair::status() const {
  return status_;
}
inline void TransferComponentsAck_pair::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// TransferComponentsAck

// repeated .network_messages.TransferComponentsAck.pair comp_status_list = 2;
inline int TransferComponentsAck::comp_status_list_size() const {
  return comp_status_list_.size();
}
inline void TransferComponentsAck::clear_comp_status_list() {
  comp_status_list_.Clear();
}
inline const ::network_messages::TransferComponentsAck_pair& TransferComponentsAck::comp_status_list(int index) const {
  return comp_status_list_.Get(index);
}
inline ::network_messages::TransferComponentsAck_pair* TransferComponentsAck::mutable_comp_status_list(int index) {
  return comp_status_list_.Mutable(index);
}
inline ::network_messages::TransferComponentsAck_pair* TransferComponentsAck::add_comp_status_list() {
  return comp_status_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComponentsAck_pair >&
TransferComponentsAck::comp_status_list() const {
  return comp_status_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComponentsAck_pair >*
TransferComponentsAck::mutable_comp_status_list() {
  return &comp_status_list_;
}

// required bool final_status = 3;
inline bool TransferComponentsAck::has_final_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferComponentsAck::set_has_final_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferComponentsAck::clear_has_final_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferComponentsAck::clear_final_status() {
  final_status_ = false;
  clear_has_final_status();
}
inline bool TransferComponentsAck::final_status() const {
  return final_status_;
}
inline void TransferComponentsAck::set_final_status(bool value) {
  set_has_final_status();
  final_status_ = value;
}

// -------------------------------------------------------------------

// GetServiceComponentAck

// repeated int32 component_list = 1;
inline int GetServiceComponentAck::component_list_size() const {
  return component_list_.size();
}
inline void GetServiceComponentAck::clear_component_list() {
  component_list_.Clear();
}
inline ::google::protobuf::int32 GetServiceComponentAck::component_list(int index) const {
  return component_list_.Get(index);
}
inline void GetServiceComponentAck::set_component_list(int index, ::google::protobuf::int32 value) {
  component_list_.Set(index, value);
}
inline void GetServiceComponentAck::add_component_list(::google::protobuf::int32 value) {
  component_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GetServiceComponentAck::component_list() const {
  return component_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GetServiceComponentAck::mutable_component_list() {
  return &component_list_;
}

// required .network_messages.errorStatus err = 2;
inline bool GetServiceComponentAck::has_err() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetServiceComponentAck::set_has_err() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetServiceComponentAck::clear_has_err() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetServiceComponentAck::clear_err() {
  if (err_ != NULL) err_->::network_messages::errorStatus::Clear();
  clear_has_err();
}
inline const ::network_messages::errorStatus& GetServiceComponentAck::err() const {
  return err_ != NULL ? *err_ : *default_instance_->err_;
}
inline ::network_messages::errorStatus* GetServiceComponentAck::mutable_err() {
  set_has_err();
  if (err_ == NULL) err_ = new ::network_messages::errorStatus;
  return err_;
}
inline ::network_messages::errorStatus* GetServiceComponentAck::release_err() {
  clear_has_err();
  ::network_messages::errorStatus* temp = err_;
  err_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetServiceComponent

// required string service_id = 1;
inline bool GetServiceComponent::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetServiceComponent::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetServiceComponent::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetServiceComponent::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& GetServiceComponent::service_id() const {
  return *service_id_;
}
inline void GetServiceComponent::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetServiceComponent::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetServiceComponent::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetServiceComponent::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* GetServiceComponent::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetGlobalMap

// required string service_id = 1;
inline bool GetGlobalMap::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGlobalMap::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGlobalMap::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGlobalMap::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& GetGlobalMap::service_id() const {
  return *service_id_;
}
inline void GetGlobalMap::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetGlobalMap::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetGlobalMap::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetGlobalMap::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* GetGlobalMap::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GlobalMapInfo_service

// repeated .network_messages.service_obj service_list = 1;
inline int GlobalMapInfo_service::service_list_size() const {
  return service_list_.size();
}
inline void GlobalMapInfo_service::clear_service_list() {
  service_list_.Clear();
}
inline const ::network_messages::service_obj& GlobalMapInfo_service::service_list(int index) const {
  return service_list_.Get(index);
}
inline ::network_messages::service_obj* GlobalMapInfo_service::mutable_service_list(int index) {
  return service_list_.Mutable(index);
}
inline ::network_messages::service_obj* GlobalMapInfo_service::add_service_list() {
  return service_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >&
GlobalMapInfo_service::service_list() const {
  return service_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >*
GlobalMapInfo_service::mutable_service_list() {
  return &service_list_;
}

// optional float version = 2;
inline bool GlobalMapInfo_service::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalMapInfo_service::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalMapInfo_service::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalMapInfo_service::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline float GlobalMapInfo_service::version() const {
  return version_;
}
inline void GlobalMapInfo_service::set_version(float value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// GlobalMapInfo

// required .network_messages.GlobalMapInfo.service container = 1;
inline bool GlobalMapInfo::has_container() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalMapInfo::set_has_container() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalMapInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalMapInfo::clear_container() {
  if (container_ != NULL) container_->::network_messages::GlobalMapInfo_service::Clear();
  clear_has_container();
}
inline const ::network_messages::GlobalMapInfo_service& GlobalMapInfo::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::network_messages::GlobalMapInfo_service* GlobalMapInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::network_messages::GlobalMapInfo_service;
  return container_;
}
inline ::network_messages::GlobalMapInfo_service* GlobalMapInfo::release_container() {
  clear_has_container();
  ::network_messages::GlobalMapInfo_service* temp = container_;
  container_ = NULL;
  return temp;
}

// required .network_messages.GlobalMapInfo.service account = 2;
inline bool GlobalMapInfo::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalMapInfo::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalMapInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalMapInfo::clear_account() {
  if (account_ != NULL) account_->::network_messages::GlobalMapInfo_service::Clear();
  clear_has_account();
}
inline const ::network_messages::GlobalMapInfo_service& GlobalMapInfo::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::network_messages::GlobalMapInfo_service* GlobalMapInfo::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::network_messages::GlobalMapInfo_service;
  return account_;
}
inline ::network_messages::GlobalMapInfo_service* GlobalMapInfo::release_account() {
  clear_has_account();
  ::network_messages::GlobalMapInfo_service* temp = account_;
  account_ = NULL;
  return temp;
}

// required .network_messages.GlobalMapInfo.service updater = 3;
inline bool GlobalMapInfo::has_updater() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlobalMapInfo::set_has_updater() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlobalMapInfo::clear_has_updater() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlobalMapInfo::clear_updater() {
  if (updater_ != NULL) updater_->::network_messages::GlobalMapInfo_service::Clear();
  clear_has_updater();
}
inline const ::network_messages::GlobalMapInfo_service& GlobalMapInfo::updater() const {
  return updater_ != NULL ? *updater_ : *default_instance_->updater_;
}
inline ::network_messages::GlobalMapInfo_service* GlobalMapInfo::mutable_updater() {
  set_has_updater();
  if (updater_ == NULL) updater_ = new ::network_messages::GlobalMapInfo_service;
  return updater_;
}
inline ::network_messages::GlobalMapInfo_service* GlobalMapInfo::release_updater() {
  clear_has_updater();
  ::network_messages::GlobalMapInfo_service* temp = updater_;
  updater_ = NULL;
  return temp;
}

// required .network_messages.GlobalMapInfo.service object = 4;
inline bool GlobalMapInfo::has_object() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GlobalMapInfo::set_has_object() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GlobalMapInfo::clear_has_object() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GlobalMapInfo::clear_object() {
  if (object_ != NULL) object_->::network_messages::GlobalMapInfo_service::Clear();
  clear_has_object();
}
inline const ::network_messages::GlobalMapInfo_service& GlobalMapInfo::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::network_messages::GlobalMapInfo_service* GlobalMapInfo::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::network_messages::GlobalMapInfo_service;
  return object_;
}
inline ::network_messages::GlobalMapInfo_service* GlobalMapInfo::release_object() {
  clear_has_object();
  ::network_messages::GlobalMapInfo_service* temp = object_;
  object_ = NULL;
  return temp;
}

// required float version = 5;
inline bool GlobalMapInfo::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GlobalMapInfo::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GlobalMapInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GlobalMapInfo::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline float GlobalMapInfo::version() const {
  return version_;
}
inline void GlobalMapInfo::set_version(float value) {
  set_has_version();
  version_ = value;
}

// required bool status = 6;
inline bool GlobalMapInfo::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GlobalMapInfo::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GlobalMapInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GlobalMapInfo::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool GlobalMapInfo::status() const {
  return status_;
}
inline void GlobalMapInfo::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// LocalLeaderStartMonitoring

// required string service_id = 1;
inline bool LocalLeaderStartMonitoring::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalLeaderStartMonitoring::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalLeaderStartMonitoring::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalLeaderStartMonitoring::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& LocalLeaderStartMonitoring::service_id() const {
  return *service_id_;
}
inline void LocalLeaderStartMonitoring::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void LocalLeaderStartMonitoring::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void LocalLeaderStartMonitoring::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalLeaderStartMonitoring::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* LocalLeaderStartMonitoring::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LocalLeaderStartMonitoringAck

// required string service_id = 1;
inline bool LocalLeaderStartMonitoringAck::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalLeaderStartMonitoringAck::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalLeaderStartMonitoringAck::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalLeaderStartMonitoringAck::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& LocalLeaderStartMonitoringAck::service_id() const {
  return *service_id_;
}
inline void LocalLeaderStartMonitoringAck::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void LocalLeaderStartMonitoringAck::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void LocalLeaderStartMonitoringAck::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalLeaderStartMonitoringAck::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* LocalLeaderStartMonitoringAck::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool status = 2;
inline bool LocalLeaderStartMonitoringAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalLeaderStartMonitoringAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalLeaderStartMonitoringAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalLeaderStartMonitoringAck::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool LocalLeaderStartMonitoringAck::status() const {
  return status_;
}
inline void LocalLeaderStartMonitoringAck::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// OsdStartMonitoring

// required string service_id = 1;
inline bool OsdStartMonitoring::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsdStartMonitoring::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsdStartMonitoring::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsdStartMonitoring::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& OsdStartMonitoring::service_id() const {
  return *service_id_;
}
inline void OsdStartMonitoring::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void OsdStartMonitoring::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void OsdStartMonitoring::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsdStartMonitoring::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* OsdStartMonitoring::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 port = 2;
inline bool OsdStartMonitoring::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsdStartMonitoring::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsdStartMonitoring::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsdStartMonitoring::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 OsdStartMonitoring::port() const {
  return port_;
}
inline void OsdStartMonitoring::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required string ip = 3;
inline bool OsdStartMonitoring::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsdStartMonitoring::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsdStartMonitoring::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsdStartMonitoring::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& OsdStartMonitoring::ip() const {
  return *ip_;
}
inline void OsdStartMonitoring::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void OsdStartMonitoring::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void OsdStartMonitoring::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsdStartMonitoring::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* OsdStartMonitoring::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OsdStartMonitoringAck

// required string service_id = 1;
inline bool OsdStartMonitoringAck::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsdStartMonitoringAck::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsdStartMonitoringAck::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsdStartMonitoringAck::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& OsdStartMonitoringAck::service_id() const {
  return *service_id_;
}
inline void OsdStartMonitoringAck::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void OsdStartMonitoringAck::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void OsdStartMonitoringAck::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsdStartMonitoringAck::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* OsdStartMonitoringAck::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .network_messages.errorStatus error = 2;
inline bool OsdStartMonitoringAck::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsdStartMonitoringAck::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsdStartMonitoringAck::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsdStartMonitoringAck::clear_error() {
  if (error_ != NULL) error_->::network_messages::errorStatus::Clear();
  clear_has_error();
}
inline const ::network_messages::errorStatus& OsdStartMonitoringAck::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::network_messages::errorStatus* OsdStartMonitoringAck::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::network_messages::errorStatus;
  return error_;
}
inline ::network_messages::errorStatus* OsdStartMonitoringAck::release_error() {
  clear_has_error();
  ::network_messages::errorStatus* temp = error_;
  error_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RecvProcStartMonitoring

// required string proc_id = 1;
inline bool RecvProcStartMonitoring::has_proc_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecvProcStartMonitoring::set_has_proc_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecvProcStartMonitoring::clear_has_proc_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecvProcStartMonitoring::clear_proc_id() {
  if (proc_id_ != &::google::protobuf::internal::kEmptyString) {
    proc_id_->clear();
  }
  clear_has_proc_id();
}
inline const ::std::string& RecvProcStartMonitoring::proc_id() const {
  return *proc_id_;
}
inline void RecvProcStartMonitoring::set_proc_id(const ::std::string& value) {
  set_has_proc_id();
  if (proc_id_ == &::google::protobuf::internal::kEmptyString) {
    proc_id_ = new ::std::string;
  }
  proc_id_->assign(value);
}
inline void RecvProcStartMonitoring::set_proc_id(const char* value) {
  set_has_proc_id();
  if (proc_id_ == &::google::protobuf::internal::kEmptyString) {
    proc_id_ = new ::std::string;
  }
  proc_id_->assign(value);
}
inline void RecvProcStartMonitoring::set_proc_id(const char* value, size_t size) {
  set_has_proc_id();
  if (proc_id_ == &::google::protobuf::internal::kEmptyString) {
    proc_id_ = new ::std::string;
  }
  proc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecvProcStartMonitoring::mutable_proc_id() {
  set_has_proc_id();
  if (proc_id_ == &::google::protobuf::internal::kEmptyString) {
    proc_id_ = new ::std::string;
  }
  return proc_id_;
}
inline ::std::string* RecvProcStartMonitoring::release_proc_id() {
  clear_has_proc_id();
  if (proc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_id_;
    proc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RecvProcStartMonitoringAck_entry

// required .network_messages.service_obj service = 1;
inline bool RecvProcStartMonitoringAck_entry::has_service() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecvProcStartMonitoringAck_entry::set_has_service() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecvProcStartMonitoringAck_entry::clear_has_service() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecvProcStartMonitoringAck_entry::clear_service() {
  if (service_ != NULL) service_->::network_messages::service_obj::Clear();
  clear_has_service();
}
inline const ::network_messages::service_obj& RecvProcStartMonitoringAck_entry::service() const {
  return service_ != NULL ? *service_ : *default_instance_->service_;
}
inline ::network_messages::service_obj* RecvProcStartMonitoringAck_entry::mutable_service() {
  set_has_service();
  if (service_ == NULL) service_ = new ::network_messages::service_obj;
  return service_;
}
inline ::network_messages::service_obj* RecvProcStartMonitoringAck_entry::release_service() {
  clear_has_service();
  ::network_messages::service_obj* temp = service_;
  service_ = NULL;
  return temp;
}

// repeated int32 component_list = 2;
inline int RecvProcStartMonitoringAck_entry::component_list_size() const {
  return component_list_.size();
}
inline void RecvProcStartMonitoringAck_entry::clear_component_list() {
  component_list_.Clear();
}
inline ::google::protobuf::int32 RecvProcStartMonitoringAck_entry::component_list(int index) const {
  return component_list_.Get(index);
}
inline void RecvProcStartMonitoringAck_entry::set_component_list(int index, ::google::protobuf::int32 value) {
  component_list_.Set(index, value);
}
inline void RecvProcStartMonitoringAck_entry::add_component_list(::google::protobuf::int32 value) {
  component_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RecvProcStartMonitoringAck_entry::component_list() const {
  return component_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RecvProcStartMonitoringAck_entry::mutable_component_list() {
  return &component_list_;
}

// -------------------------------------------------------------------

// RecvProcStartMonitoringAck

// repeated .network_messages.RecvProcStartMonitoringAck.entry service_name = 1;
inline int RecvProcStartMonitoringAck::service_name_size() const {
  return service_name_.size();
}
inline void RecvProcStartMonitoringAck::clear_service_name() {
  service_name_.Clear();
}
inline const ::network_messages::RecvProcStartMonitoringAck_entry& RecvProcStartMonitoringAck::service_name(int index) const {
  return service_name_.Get(index);
}
inline ::network_messages::RecvProcStartMonitoringAck_entry* RecvProcStartMonitoringAck::mutable_service_name(int index) {
  return service_name_.Mutable(index);
}
inline ::network_messages::RecvProcStartMonitoringAck_entry* RecvProcStartMonitoringAck::add_service_name() {
  return service_name_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::RecvProcStartMonitoringAck_entry >&
RecvProcStartMonitoringAck::service_name() const {
  return service_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::RecvProcStartMonitoringAck_entry >*
RecvProcStartMonitoringAck::mutable_service_name() {
  return &service_name_;
}

// optional .network_messages.service_obj source_service = 2;
inline bool RecvProcStartMonitoringAck::has_source_service() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecvProcStartMonitoringAck::set_has_source_service() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecvProcStartMonitoringAck::clear_has_source_service() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecvProcStartMonitoringAck::clear_source_service() {
  if (source_service_ != NULL) source_service_->::network_messages::service_obj::Clear();
  clear_has_source_service();
}
inline const ::network_messages::service_obj& RecvProcStartMonitoringAck::source_service() const {
  return source_service_ != NULL ? *source_service_ : *default_instance_->source_service_;
}
inline ::network_messages::service_obj* RecvProcStartMonitoringAck::mutable_source_service() {
  set_has_source_service();
  if (source_service_ == NULL) source_service_ = new ::network_messages::service_obj;
  return source_service_;
}
inline ::network_messages::service_obj* RecvProcStartMonitoringAck::release_source_service() {
  clear_has_source_service();
  ::network_messages::service_obj* temp = source_service_;
  source_service_ = NULL;
  return temp;
}

// required bool status = 3;
inline bool RecvProcStartMonitoringAck::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecvProcStartMonitoringAck::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecvProcStartMonitoringAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecvProcStartMonitoringAck::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool RecvProcStartMonitoringAck::status() const {
  return status_;
}
inline void RecvProcStartMonitoringAck::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// CompTransferInfo_pair

// required int32 component = 1;
inline bool CompTransferInfo_pair::has_component() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompTransferInfo_pair::set_has_component() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompTransferInfo_pair::clear_has_component() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompTransferInfo_pair::clear_component() {
  component_ = 0;
  clear_has_component();
}
inline ::google::protobuf::int32 CompTransferInfo_pair::component() const {
  return component_;
}
inline void CompTransferInfo_pair::set_component(::google::protobuf::int32 value) {
  set_has_component();
  component_ = value;
}

// required .network_messages.service_obj dest_service = 2;
inline bool CompTransferInfo_pair::has_dest_service() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompTransferInfo_pair::set_has_dest_service() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompTransferInfo_pair::clear_has_dest_service() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompTransferInfo_pair::clear_dest_service() {
  if (dest_service_ != NULL) dest_service_->::network_messages::service_obj::Clear();
  clear_has_dest_service();
}
inline const ::network_messages::service_obj& CompTransferInfo_pair::dest_service() const {
  return dest_service_ != NULL ? *dest_service_ : *default_instance_->dest_service_;
}
inline ::network_messages::service_obj* CompTransferInfo_pair::mutable_dest_service() {
  set_has_dest_service();
  if (dest_service_ == NULL) dest_service_ = new ::network_messages::service_obj;
  return dest_service_;
}
inline ::network_messages::service_obj* CompTransferInfo_pair::release_dest_service() {
  clear_has_dest_service();
  ::network_messages::service_obj* temp = dest_service_;
  dest_service_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CompTransferInfo

// required string service_id = 1;
inline bool CompTransferInfo::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompTransferInfo::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompTransferInfo::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompTransferInfo::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& CompTransferInfo::service_id() const {
  return *service_id_;
}
inline void CompTransferInfo::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void CompTransferInfo::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void CompTransferInfo::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompTransferInfo::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* CompTransferInfo::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .network_messages.CompTransferInfo.pair component_service_pair = 2;
inline int CompTransferInfo::component_service_pair_size() const {
  return component_service_pair_.size();
}
inline void CompTransferInfo::clear_component_service_pair() {
  component_service_pair_.Clear();
}
inline const ::network_messages::CompTransferInfo_pair& CompTransferInfo::component_service_pair(int index) const {
  return component_service_pair_.Get(index);
}
inline ::network_messages::CompTransferInfo_pair* CompTransferInfo::mutable_component_service_pair(int index) {
  return component_service_pair_.Mutable(index);
}
inline ::network_messages::CompTransferInfo_pair* CompTransferInfo::add_component_service_pair() {
  return component_service_pair_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::CompTransferInfo_pair >&
CompTransferInfo::component_service_pair() const {
  return component_service_pair_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::CompTransferInfo_pair >*
CompTransferInfo::mutable_component_service_pair() {
  return &component_service_pair_;
}

// -------------------------------------------------------------------

// CompTranferFinalStat_pair

// required int32 component = 1;
inline bool CompTranferFinalStat_pair::has_component() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompTranferFinalStat_pair::set_has_component() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompTranferFinalStat_pair::clear_has_component() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompTranferFinalStat_pair::clear_component() {
  component_ = 0;
  clear_has_component();
}
inline ::google::protobuf::int32 CompTranferFinalStat_pair::component() const {
  return component_;
}
inline void CompTranferFinalStat_pair::set_component(::google::protobuf::int32 value) {
  set_has_component();
  component_ = value;
}

// required bool status = 2;
inline bool CompTranferFinalStat_pair::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompTranferFinalStat_pair::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompTranferFinalStat_pair::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompTranferFinalStat_pair::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool CompTranferFinalStat_pair::status() const {
  return status_;
}
inline void CompTranferFinalStat_pair::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// CompTranferFinalStat

// required string service_id = 1;
inline bool CompTranferFinalStat::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompTranferFinalStat::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompTranferFinalStat::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompTranferFinalStat::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& CompTranferFinalStat::service_id() const {
  return *service_id_;
}
inline void CompTranferFinalStat::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void CompTranferFinalStat::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void CompTranferFinalStat::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompTranferFinalStat::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* CompTranferFinalStat::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .network_messages.CompTranferFinalStat.pair comp_status_list = 2;
inline int CompTranferFinalStat::comp_status_list_size() const {
  return comp_status_list_.size();
}
inline void CompTranferFinalStat::clear_comp_status_list() {
  comp_status_list_.Clear();
}
inline const ::network_messages::CompTranferFinalStat_pair& CompTranferFinalStat::comp_status_list(int index) const {
  return comp_status_list_.Get(index);
}
inline ::network_messages::CompTranferFinalStat_pair* CompTranferFinalStat::mutable_comp_status_list(int index) {
  return comp_status_list_.Mutable(index);
}
inline ::network_messages::CompTranferFinalStat_pair* CompTranferFinalStat::add_comp_status_list() {
  return comp_status_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::CompTranferFinalStat_pair >&
CompTranferFinalStat::comp_status_list() const {
  return comp_status_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::CompTranferFinalStat_pair >*
CompTranferFinalStat::mutable_comp_status_list() {
  return &comp_status_list_;
}

// required bool final_status = 3;
inline bool CompTranferFinalStat::has_final_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompTranferFinalStat::set_has_final_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompTranferFinalStat::clear_has_final_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompTranferFinalStat::clear_final_status() {
  final_status_ = false;
  clear_has_final_status();
}
inline bool CompTranferFinalStat::final_status() const {
  return final_status_;
}
inline void CompTranferFinalStat::set_final_status(bool value) {
  set_has_final_status();
  final_status_ = value;
}

// -------------------------------------------------------------------

// TransferComp_pair

// required .network_messages.service_obj dest_service = 1;
inline bool TransferComp_pair::has_dest_service() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferComp_pair::set_has_dest_service() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferComp_pair::clear_has_dest_service() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferComp_pair::clear_dest_service() {
  if (dest_service_ != NULL) dest_service_->::network_messages::service_obj::Clear();
  clear_has_dest_service();
}
inline const ::network_messages::service_obj& TransferComp_pair::dest_service() const {
  return dest_service_ != NULL ? *dest_service_ : *default_instance_->dest_service_;
}
inline ::network_messages::service_obj* TransferComp_pair::mutable_dest_service() {
  set_has_dest_service();
  if (dest_service_ == NULL) dest_service_ = new ::network_messages::service_obj;
  return dest_service_;
}
inline ::network_messages::service_obj* TransferComp_pair::release_dest_service() {
  clear_has_dest_service();
  ::network_messages::service_obj* temp = dest_service_;
  dest_service_ = NULL;
  return temp;
}

// repeated int32 component = 2;
inline int TransferComp_pair::component_size() const {
  return component_.size();
}
inline void TransferComp_pair::clear_component() {
  component_.Clear();
}
inline ::google::protobuf::int32 TransferComp_pair::component(int index) const {
  return component_.Get(index);
}
inline void TransferComp_pair::set_component(int index, ::google::protobuf::int32 value) {
  component_.Set(index, value);
}
inline void TransferComp_pair::add_component(::google::protobuf::int32 value) {
  component_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TransferComp_pair::component() const {
  return component_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TransferComp_pair::mutable_component() {
  return &component_;
}

// -------------------------------------------------------------------

// TransferComp

// repeated .network_messages.TransferComp.pair service_comp_list = 1;
inline int TransferComp::service_comp_list_size() const {
  return service_comp_list_.size();
}
inline void TransferComp::clear_service_comp_list() {
  service_comp_list_.Clear();
}
inline const ::network_messages::TransferComp_pair& TransferComp::service_comp_list(int index) const {
  return service_comp_list_.Get(index);
}
inline ::network_messages::TransferComp_pair* TransferComp::mutable_service_comp_list(int index) {
  return service_comp_list_.Mutable(index);
}
inline ::network_messages::TransferComp_pair* TransferComp::add_service_comp_list() {
  return service_comp_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComp_pair >&
TransferComp::service_comp_list() const {
  return service_comp_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::TransferComp_pair >*
TransferComp::mutable_service_comp_list() {
  return &service_comp_list_;
}

// -------------------------------------------------------------------

// NodeAdditionCli

// repeated .network_messages.service_obj node_list = 1;
inline int NodeAdditionCli::node_list_size() const {
  return node_list_.size();
}
inline void NodeAdditionCli::clear_node_list() {
  node_list_.Clear();
}
inline const ::network_messages::service_obj& NodeAdditionCli::node_list(int index) const {
  return node_list_.Get(index);
}
inline ::network_messages::service_obj* NodeAdditionCli::mutable_node_list(int index) {
  return node_list_.Mutable(index);
}
inline ::network_messages::service_obj* NodeAdditionCli::add_node_list() {
  return node_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >&
NodeAdditionCli::node_list() const {
  return node_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >*
NodeAdditionCli::mutable_node_list() {
  return &node_list_;
}

// -------------------------------------------------------------------

// NodeAdditionCliAck_pair

// required .network_messages.errorStatus status = 1;
inline bool NodeAdditionCliAck_pair::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeAdditionCliAck_pair::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeAdditionCliAck_pair::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeAdditionCliAck_pair::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeAdditionCliAck_pair::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeAdditionCliAck_pair::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeAdditionCliAck_pair::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// required .network_messages.service_obj node = 2;
inline bool NodeAdditionCliAck_pair::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeAdditionCliAck_pair::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeAdditionCliAck_pair::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeAdditionCliAck_pair::clear_node() {
  if (node_ != NULL) node_->::network_messages::service_obj::Clear();
  clear_has_node();
}
inline const ::network_messages::service_obj& NodeAdditionCliAck_pair::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::network_messages::service_obj* NodeAdditionCliAck_pair::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::network_messages::service_obj;
  return node_;
}
inline ::network_messages::service_obj* NodeAdditionCliAck_pair::release_node() {
  clear_has_node();
  ::network_messages::service_obj* temp = node_;
  node_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeAdditionCliAck

// repeated .network_messages.NodeAdditionCliAck.pair node_ack_list = 1;
inline int NodeAdditionCliAck::node_ack_list_size() const {
  return node_ack_list_.size();
}
inline void NodeAdditionCliAck::clear_node_ack_list() {
  node_ack_list_.Clear();
}
inline const ::network_messages::NodeAdditionCliAck_pair& NodeAdditionCliAck::node_ack_list(int index) const {
  return node_ack_list_.Get(index);
}
inline ::network_messages::NodeAdditionCliAck_pair* NodeAdditionCliAck::mutable_node_ack_list(int index) {
  return node_ack_list_.Mutable(index);
}
inline ::network_messages::NodeAdditionCliAck_pair* NodeAdditionCliAck::add_node_ack_list() {
  return node_ack_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::NodeAdditionCliAck_pair >&
NodeAdditionCliAck::node_ack_list() const {
  return node_ack_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::NodeAdditionCliAck_pair >*
NodeAdditionCliAck::mutable_node_ack_list() {
  return &node_ack_list_;
}

// -------------------------------------------------------------------

// NodeAdditionGl

// required string service_id = 1;
inline bool NodeAdditionGl::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeAdditionGl::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeAdditionGl::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeAdditionGl::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& NodeAdditionGl::service_id() const {
  return *service_id_;
}
inline void NodeAdditionGl::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void NodeAdditionGl::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void NodeAdditionGl::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeAdditionGl::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* NodeAdditionGl::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NodeAdditionGlAck

// required .network_messages.errorStatus status = 1;
inline bool NodeAdditionGlAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeAdditionGlAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeAdditionGlAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeAdditionGlAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeAdditionGlAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeAdditionGlAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeAdditionGlAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// repeated .network_messages.service_obj service_list = 2;
inline int NodeAdditionGlAck::service_list_size() const {
  return service_list_.size();
}
inline void NodeAdditionGlAck::clear_service_list() {
  service_list_.Clear();
}
inline const ::network_messages::service_obj& NodeAdditionGlAck::service_list(int index) const {
  return service_list_.Get(index);
}
inline ::network_messages::service_obj* NodeAdditionGlAck::mutable_service_list(int index) {
  return service_list_.Mutable(index);
}
inline ::network_messages::service_obj* NodeAdditionGlAck::add_service_list() {
  return service_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >&
NodeAdditionGlAck::service_list() const {
  return service_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::service_obj >*
NodeAdditionGlAck::mutable_service_list() {
  return &service_list_;
}

// -------------------------------------------------------------------

// NodeStopLL

// required .network_messages.service_obj node = 1;
inline bool NodeStopLL::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeStopLL::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeStopLL::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeStopLL::clear_node() {
  if (node_ != NULL) node_->::network_messages::service_obj::Clear();
  clear_has_node();
}
inline const ::network_messages::service_obj& NodeStopLL::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::network_messages::service_obj* NodeStopLL::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::network_messages::service_obj;
  return node_;
}
inline ::network_messages::service_obj* NodeStopLL::release_node() {
  clear_has_node();
  ::network_messages::service_obj* temp = node_;
  node_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeStopLLAck

// required string node_id = 1;
inline bool NodeStopLLAck::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeStopLLAck::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeStopLLAck::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeStopLLAck::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeStopLLAck::node_id() const {
  return *node_id_;
}
inline void NodeStopLLAck::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeStopLLAck::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeStopLLAck::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeStopLLAck::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeStopLLAck::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .network_messages.errorStatus status = 2;
inline bool NodeStopLLAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeStopLLAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeStopLLAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeStopLLAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeStopLLAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeStopLLAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeStopLLAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// required int32 node_status = 3;
inline bool NodeStopLLAck::has_node_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeStopLLAck::set_has_node_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeStopLLAck::clear_has_node_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeStopLLAck::clear_node_status() {
  node_status_ = 0;
  clear_has_node_status();
}
inline ::google::protobuf::int32 NodeStopLLAck::node_status() const {
  return node_status_;
}
inline void NodeStopLLAck::set_node_status(::google::protobuf::int32 value) {
  set_has_node_status();
  node_status_ = value;
}

// -------------------------------------------------------------------

// NodeRetire

// required .network_messages.service_obj node = 1;
inline bool NodeRetire::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeRetire::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeRetire::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeRetire::clear_node() {
  if (node_ != NULL) node_->::network_messages::service_obj::Clear();
  clear_has_node();
}
inline const ::network_messages::service_obj& NodeRetire::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::network_messages::service_obj* NodeRetire::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::network_messages::service_obj;
  return node_;
}
inline ::network_messages::service_obj* NodeRetire::release_node() {
  clear_has_node();
  ::network_messages::service_obj* temp = node_;
  node_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeRetireAck

// required string node_id = 1;
inline bool NodeRetireAck::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeRetireAck::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeRetireAck::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeRetireAck::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeRetireAck::node_id() const {
  return *node_id_;
}
inline void NodeRetireAck::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeRetireAck::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeRetireAck::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeRetireAck::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeRetireAck::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .network_messages.errorStatus status = 2;
inline bool NodeRetireAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeRetireAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeRetireAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeRetireAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeRetireAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeRetireAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeRetireAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeDeletionCli

// required .network_messages.service_obj node = 1;
inline bool NodeDeletionCli::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeDeletionCli::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeDeletionCli::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeDeletionCli::clear_node() {
  if (node_ != NULL) node_->::network_messages::service_obj::Clear();
  clear_has_node();
}
inline const ::network_messages::service_obj& NodeDeletionCli::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::network_messages::service_obj* NodeDeletionCli::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::network_messages::service_obj;
  return node_;
}
inline ::network_messages::service_obj* NodeDeletionCli::release_node() {
  clear_has_node();
  ::network_messages::service_obj* temp = node_;
  node_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeDeletionCliAck

// required string node_id = 1;
inline bool NodeDeletionCliAck::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeDeletionCliAck::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeDeletionCliAck::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeDeletionCliAck::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeDeletionCliAck::node_id() const {
  return *node_id_;
}
inline void NodeDeletionCliAck::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeDeletionCliAck::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeDeletionCliAck::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeDeletionCliAck::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeDeletionCliAck::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .network_messages.errorStatus status = 2;
inline bool NodeDeletionCliAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeDeletionCliAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeDeletionCliAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeDeletionCliAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeDeletionCliAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeDeletionCliAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeDeletionCliAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeSystemStopCli

// required string node_id = 1;
inline bool NodeSystemStopCli::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeSystemStopCli::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeSystemStopCli::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeSystemStopCli::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeSystemStopCli::node_id() const {
  return *node_id_;
}
inline void NodeSystemStopCli::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeSystemStopCli::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeSystemStopCli::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeSystemStopCli::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeSystemStopCli::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LocalNodeStatus

// required string node_id = 1;
inline bool LocalNodeStatus::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalNodeStatus::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalNodeStatus::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalNodeStatus::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& LocalNodeStatus::node_id() const {
  return *node_id_;
}
inline void LocalNodeStatus::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void LocalNodeStatus::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void LocalNodeStatus::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalNodeStatus::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* LocalNodeStatus::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NodeStatus

// required .network_messages.service_obj node = 1;
inline bool NodeStatus::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeStatus::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeStatus::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeStatus::clear_node() {
  if (node_ != NULL) node_->::network_messages::service_obj::Clear();
  clear_has_node();
}
inline const ::network_messages::service_obj& NodeStatus::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::network_messages::service_obj* NodeStatus::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::network_messages::service_obj;
  return node_;
}
inline ::network_messages::service_obj* NodeStatus::release_node() {
  clear_has_node();
  ::network_messages::service_obj* temp = node_;
  node_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeStatusAck

// required .network_messages.NodeStatusEnum status = 1 [default = INVALID_NODE];
inline bool NodeStatusAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeStatusAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeStatusAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeStatusAck::clear_status() {
  status_ = 100;
  clear_has_status();
}
inline network_messages::NodeStatusEnum NodeStatusAck::status() const {
  return static_cast< network_messages::NodeStatusEnum >(status_);
}
inline void NodeStatusAck::set_status(network_messages::NodeStatusEnum value) {
  GOOGLE_DCHECK(network_messages::NodeStatusEnum_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// NodeStopCli

// required string node_id = 1;
inline bool NodeStopCli::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeStopCli::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeStopCli::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeStopCli::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeStopCli::node_id() const {
  return *node_id_;
}
inline void NodeStopCli::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeStopCli::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeStopCli::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeStopCli::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeStopCli::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NodeStopCliAck

// required .network_messages.errorStatus status = 1;
inline bool NodeStopCliAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeStopCliAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeStopCliAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeStopCliAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeStopCliAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeStopCliAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeStopCliAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// StopServices

// required string service_id = 1;
inline bool StopServices::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopServices::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopServices::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopServices::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& StopServices::service_id() const {
  return *service_id_;
}
inline void StopServices::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void StopServices::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void StopServices::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StopServices::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* StopServices::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StopServicesAck

// required .network_messages.errorStatus status = 1;
inline bool StopServicesAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopServicesAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopServicesAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopServicesAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& StopServicesAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* StopServicesAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* StopServicesAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeFailover

// required string node_id = 1;
inline bool NodeFailover::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeFailover::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeFailover::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeFailover::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeFailover::node_id() const {
  return *node_id_;
}
inline void NodeFailover::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeFailover::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeFailover::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeFailover::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeFailover::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .network_messages.errorStatus status = 2;
inline bool NodeFailover::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeFailover::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeFailover::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeFailover::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeFailover::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeFailover::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeFailover::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NodeFailoverAck

// required .network_messages.errorStatus status = 2;
inline bool NodeFailoverAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeFailoverAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeFailoverAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeFailoverAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeFailoverAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeFailoverAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeFailoverAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// TakeGlOwnership

// required string old_gl_id = 1;
inline bool TakeGlOwnership::has_old_gl_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TakeGlOwnership::set_has_old_gl_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TakeGlOwnership::clear_has_old_gl_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TakeGlOwnership::clear_old_gl_id() {
  if (old_gl_id_ != &::google::protobuf::internal::kEmptyString) {
    old_gl_id_->clear();
  }
  clear_has_old_gl_id();
}
inline const ::std::string& TakeGlOwnership::old_gl_id() const {
  return *old_gl_id_;
}
inline void TakeGlOwnership::set_old_gl_id(const ::std::string& value) {
  set_has_old_gl_id();
  if (old_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    old_gl_id_ = new ::std::string;
  }
  old_gl_id_->assign(value);
}
inline void TakeGlOwnership::set_old_gl_id(const char* value) {
  set_has_old_gl_id();
  if (old_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    old_gl_id_ = new ::std::string;
  }
  old_gl_id_->assign(value);
}
inline void TakeGlOwnership::set_old_gl_id(const char* value, size_t size) {
  set_has_old_gl_id();
  if (old_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    old_gl_id_ = new ::std::string;
  }
  old_gl_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TakeGlOwnership::mutable_old_gl_id() {
  set_has_old_gl_id();
  if (old_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    old_gl_id_ = new ::std::string;
  }
  return old_gl_id_;
}
inline ::std::string* TakeGlOwnership::release_old_gl_id() {
  clear_has_old_gl_id();
  if (old_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_gl_id_;
    old_gl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string new_gl_id = 2;
inline bool TakeGlOwnership::has_new_gl_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TakeGlOwnership::set_has_new_gl_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TakeGlOwnership::clear_has_new_gl_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TakeGlOwnership::clear_new_gl_id() {
  if (new_gl_id_ != &::google::protobuf::internal::kEmptyString) {
    new_gl_id_->clear();
  }
  clear_has_new_gl_id();
}
inline const ::std::string& TakeGlOwnership::new_gl_id() const {
  return *new_gl_id_;
}
inline void TakeGlOwnership::set_new_gl_id(const ::std::string& value) {
  set_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    new_gl_id_ = new ::std::string;
  }
  new_gl_id_->assign(value);
}
inline void TakeGlOwnership::set_new_gl_id(const char* value) {
  set_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    new_gl_id_ = new ::std::string;
  }
  new_gl_id_->assign(value);
}
inline void TakeGlOwnership::set_new_gl_id(const char* value, size_t size) {
  set_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    new_gl_id_ = new ::std::string;
  }
  new_gl_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TakeGlOwnership::mutable_new_gl_id() {
  set_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    new_gl_id_ = new ::std::string;
  }
  return new_gl_id_;
}
inline ::std::string* TakeGlOwnership::release_new_gl_id() {
  clear_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_gl_id_;
    new_gl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TakeGlOwnershipAck

// required string new_gl_id = 1;
inline bool TakeGlOwnershipAck::has_new_gl_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TakeGlOwnershipAck::set_has_new_gl_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TakeGlOwnershipAck::clear_has_new_gl_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TakeGlOwnershipAck::clear_new_gl_id() {
  if (new_gl_id_ != &::google::protobuf::internal::kEmptyString) {
    new_gl_id_->clear();
  }
  clear_has_new_gl_id();
}
inline const ::std::string& TakeGlOwnershipAck::new_gl_id() const {
  return *new_gl_id_;
}
inline void TakeGlOwnershipAck::set_new_gl_id(const ::std::string& value) {
  set_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    new_gl_id_ = new ::std::string;
  }
  new_gl_id_->assign(value);
}
inline void TakeGlOwnershipAck::set_new_gl_id(const char* value) {
  set_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    new_gl_id_ = new ::std::string;
  }
  new_gl_id_->assign(value);
}
inline void TakeGlOwnershipAck::set_new_gl_id(const char* value, size_t size) {
  set_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    new_gl_id_ = new ::std::string;
  }
  new_gl_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TakeGlOwnershipAck::mutable_new_gl_id() {
  set_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    new_gl_id_ = new ::std::string;
  }
  return new_gl_id_;
}
inline ::std::string* TakeGlOwnershipAck::release_new_gl_id() {
  clear_has_new_gl_id();
  if (new_gl_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_gl_id_;
    new_gl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .network_messages.errorStatus status = 2;
inline bool TakeGlOwnershipAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TakeGlOwnershipAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TakeGlOwnershipAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TakeGlOwnershipAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& TakeGlOwnershipAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* TakeGlOwnershipAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* TakeGlOwnershipAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetObjectVersion

// required string service_id = 1;
inline bool GetObjectVersion::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetObjectVersion::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetObjectVersion::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetObjectVersion::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& GetObjectVersion::service_id() const {
  return *service_id_;
}
inline void GetObjectVersion::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetObjectVersion::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetObjectVersion::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetObjectVersion::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* GetObjectVersion::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetObjectVersionAck

// required string service_id = 1;
inline bool GetObjectVersionAck::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetObjectVersionAck::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetObjectVersionAck::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetObjectVersionAck::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& GetObjectVersionAck::service_id() const {
  return *service_id_;
}
inline void GetObjectVersionAck::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetObjectVersionAck::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetObjectVersionAck::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetObjectVersionAck::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* GetObjectVersionAck::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 object_version = 2;
inline bool GetObjectVersionAck::has_object_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetObjectVersionAck::set_has_object_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetObjectVersionAck::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetObjectVersionAck::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 GetObjectVersionAck::object_version() const {
  return object_version_;
}
inline void GetObjectVersionAck::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// required bool status = 3;
inline bool GetObjectVersionAck::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetObjectVersionAck::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetObjectVersionAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetObjectVersionAck::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool GetObjectVersionAck::status() const {
  return status_;
}
inline void GetObjectVersionAck::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// NodeRejoinAfterRecovery

// required string node_id = 1;
inline bool NodeRejoinAfterRecovery::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeRejoinAfterRecovery::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeRejoinAfterRecovery::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeRejoinAfterRecovery::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeRejoinAfterRecovery::node_id() const {
  return *node_id_;
}
inline void NodeRejoinAfterRecovery::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeRejoinAfterRecovery::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeRejoinAfterRecovery::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeRejoinAfterRecovery::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeRejoinAfterRecovery::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string node_ip = 2;
inline bool NodeRejoinAfterRecovery::has_node_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeRejoinAfterRecovery::set_has_node_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeRejoinAfterRecovery::clear_has_node_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeRejoinAfterRecovery::clear_node_ip() {
  if (node_ip_ != &::google::protobuf::internal::kEmptyString) {
    node_ip_->clear();
  }
  clear_has_node_ip();
}
inline const ::std::string& NodeRejoinAfterRecovery::node_ip() const {
  return *node_ip_;
}
inline void NodeRejoinAfterRecovery::set_node_ip(const ::std::string& value) {
  set_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    node_ip_ = new ::std::string;
  }
  node_ip_->assign(value);
}
inline void NodeRejoinAfterRecovery::set_node_ip(const char* value) {
  set_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    node_ip_ = new ::std::string;
  }
  node_ip_->assign(value);
}
inline void NodeRejoinAfterRecovery::set_node_ip(const char* value, size_t size) {
  set_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    node_ip_ = new ::std::string;
  }
  node_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeRejoinAfterRecovery::mutable_node_ip() {
  set_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    node_ip_ = new ::std::string;
  }
  return node_ip_;
}
inline ::std::string* NodeRejoinAfterRecovery::release_node_ip() {
  clear_has_node_ip();
  if (node_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_ip_;
    node_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 node_port = 3;
inline bool NodeRejoinAfterRecovery::has_node_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeRejoinAfterRecovery::set_has_node_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeRejoinAfterRecovery::clear_has_node_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeRejoinAfterRecovery::clear_node_port() {
  node_port_ = 0;
  clear_has_node_port();
}
inline ::google::protobuf::int32 NodeRejoinAfterRecovery::node_port() const {
  return node_port_;
}
inline void NodeRejoinAfterRecovery::set_node_port(::google::protobuf::int32 value) {
  set_has_node_port();
  node_port_ = value;
}

// -------------------------------------------------------------------

// NodeRejoinAfterRecoveryAck

// required string node_id = 1;
inline bool NodeRejoinAfterRecoveryAck::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeRejoinAfterRecoveryAck::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeRejoinAfterRecoveryAck::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeRejoinAfterRecoveryAck::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeRejoinAfterRecoveryAck::node_id() const {
  return *node_id_;
}
inline void NodeRejoinAfterRecoveryAck::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeRejoinAfterRecoveryAck::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeRejoinAfterRecoveryAck::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeRejoinAfterRecoveryAck::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeRejoinAfterRecoveryAck::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .network_messages.errorStatus status = 2;
inline bool NodeRejoinAfterRecoveryAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeRejoinAfterRecoveryAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeRejoinAfterRecoveryAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeRejoinAfterRecoveryAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& NodeRejoinAfterRecoveryAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* NodeRejoinAfterRecoveryAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* NodeRejoinAfterRecoveryAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetClusterStatus

// required string service_id = 1;
inline bool GetClusterStatus::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterStatus::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterStatus::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterStatus::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& GetClusterStatus::service_id() const {
  return *service_id_;
}
inline void GetClusterStatus::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetClusterStatus::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void GetClusterStatus::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetClusterStatus::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* GetClusterStatus::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetClusterStatusAck_pair

// required string node_id = 1;
inline bool GetClusterStatusAck_pair::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterStatusAck_pair::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterStatusAck_pair::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterStatusAck_pair::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::kEmptyString) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& GetClusterStatusAck_pair::node_id() const {
  return *node_id_;
}
inline void GetClusterStatusAck_pair::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void GetClusterStatusAck_pair::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void GetClusterStatusAck_pair::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetClusterStatusAck_pair::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* GetClusterStatusAck_pair::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .network_messages.NodeStatusEnum status_enum = 2;
inline bool GetClusterStatusAck_pair::has_status_enum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetClusterStatusAck_pair::set_has_status_enum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetClusterStatusAck_pair::clear_has_status_enum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetClusterStatusAck_pair::clear_status_enum() {
  status_enum_ = 10;
  clear_has_status_enum();
}
inline network_messages::NodeStatusEnum GetClusterStatusAck_pair::status_enum() const {
  return static_cast< network_messages::NodeStatusEnum >(status_enum_);
}
inline void GetClusterStatusAck_pair::set_status_enum(network_messages::NodeStatusEnum value) {
  GOOGLE_DCHECK(network_messages::NodeStatusEnum_IsValid(value));
  set_has_status_enum();
  status_enum_ = value;
}

// -------------------------------------------------------------------

// GetClusterStatusAck

// repeated .network_messages.GetClusterStatusAck.pair node_status_list = 1;
inline int GetClusterStatusAck::node_status_list_size() const {
  return node_status_list_.size();
}
inline void GetClusterStatusAck::clear_node_status_list() {
  node_status_list_.Clear();
}
inline const ::network_messages::GetClusterStatusAck_pair& GetClusterStatusAck::node_status_list(int index) const {
  return node_status_list_.Get(index);
}
inline ::network_messages::GetClusterStatusAck_pair* GetClusterStatusAck::mutable_node_status_list(int index) {
  return node_status_list_.Mutable(index);
}
inline ::network_messages::GetClusterStatusAck_pair* GetClusterStatusAck::add_node_status_list() {
  return node_status_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network_messages::GetClusterStatusAck_pair >&
GetClusterStatusAck::node_status_list() const {
  return node_status_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::network_messages::GetClusterStatusAck_pair >*
GetClusterStatusAck::mutable_node_status_list() {
  return &node_status_list_;
}

// required .network_messages.errorStatus status = 2;
inline bool GetClusterStatusAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetClusterStatusAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetClusterStatusAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetClusterStatusAck::clear_status() {
  if (status_ != NULL) status_->::network_messages::errorStatus::Clear();
  clear_has_status();
}
inline const ::network_messages::errorStatus& GetClusterStatusAck::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::network_messages::errorStatus* GetClusterStatusAck::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::network_messages::errorStatus;
  return status_;
}
inline ::network_messages::errorStatus* GetClusterStatusAck::release_status() {
  clear_has_status();
  ::network_messages::errorStatus* temp = status_;
  status_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpdateContainer

// required string meta_file_path = 1;
inline bool UpdateContainer::has_meta_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateContainer::set_has_meta_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateContainer::clear_has_meta_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateContainer::clear_meta_file_path() {
  if (meta_file_path_ != &::google::protobuf::internal::kEmptyString) {
    meta_file_path_->clear();
  }
  clear_has_meta_file_path();
}
inline const ::std::string& UpdateContainer::meta_file_path() const {
  return *meta_file_path_;
}
inline void UpdateContainer::set_meta_file_path(const ::std::string& value) {
  set_has_meta_file_path();
  if (meta_file_path_ == &::google::protobuf::internal::kEmptyString) {
    meta_file_path_ = new ::std::string;
  }
  meta_file_path_->assign(value);
}
inline void UpdateContainer::set_meta_file_path(const char* value) {
  set_has_meta_file_path();
  if (meta_file_path_ == &::google::protobuf::internal::kEmptyString) {
    meta_file_path_ = new ::std::string;
  }
  meta_file_path_->assign(value);
}
inline void UpdateContainer::set_meta_file_path(const char* value, size_t size) {
  set_has_meta_file_path();
  if (meta_file_path_ == &::google::protobuf::internal::kEmptyString) {
    meta_file_path_ = new ::std::string;
  }
  meta_file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateContainer::mutable_meta_file_path() {
  set_has_meta_file_path();
  if (meta_file_path_ == &::google::protobuf::internal::kEmptyString) {
    meta_file_path_ = new ::std::string;
  }
  return meta_file_path_;
}
inline ::std::string* UpdateContainer::release_meta_file_path() {
  clear_has_meta_file_path();
  if (meta_file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meta_file_path_;
    meta_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string operation = 2;
inline bool UpdateContainer::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateContainer::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateContainer::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateContainer::clear_operation() {
  if (operation_ != &::google::protobuf::internal::kEmptyString) {
    operation_->clear();
  }
  clear_has_operation();
}
inline const ::std::string& UpdateContainer::operation() const {
  return *operation_;
}
inline void UpdateContainer::set_operation(const ::std::string& value) {
  set_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    operation_ = new ::std::string;
  }
  operation_->assign(value);
}
inline void UpdateContainer::set_operation(const char* value) {
  set_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    operation_ = new ::std::string;
  }
  operation_->assign(value);
}
inline void UpdateContainer::set_operation(const char* value, size_t size) {
  set_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    operation_ = new ::std::string;
  }
  operation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateContainer::mutable_operation() {
  set_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    operation_ = new ::std::string;
  }
  return operation_;
}
inline ::std::string* UpdateContainer::release_operation() {
  clear_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operation_;
    operation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReleaseTransactionLock

// required string lock = 1;
inline bool ReleaseTransactionLock::has_lock() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReleaseTransactionLock::set_has_lock() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReleaseTransactionLock::clear_has_lock() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReleaseTransactionLock::clear_lock() {
  if (lock_ != &::google::protobuf::internal::kEmptyString) {
    lock_->clear();
  }
  clear_has_lock();
}
inline const ::std::string& ReleaseTransactionLock::lock() const {
  return *lock_;
}
inline void ReleaseTransactionLock::set_lock(const ::std::string& value) {
  set_has_lock();
  if (lock_ == &::google::protobuf::internal::kEmptyString) {
    lock_ = new ::std::string;
  }
  lock_->assign(value);
}
inline void ReleaseTransactionLock::set_lock(const char* value) {
  set_has_lock();
  if (lock_ == &::google::protobuf::internal::kEmptyString) {
    lock_ = new ::std::string;
  }
  lock_->assign(value);
}
inline void ReleaseTransactionLock::set_lock(const char* value, size_t size) {
  set_has_lock();
  if (lock_ == &::google::protobuf::internal::kEmptyString) {
    lock_ = new ::std::string;
  }
  lock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseTransactionLock::mutable_lock() {
  set_has_lock();
  if (lock_ == &::google::protobuf::internal::kEmptyString) {
    lock_ = new ::std::string;
  }
  return lock_;
}
inline ::std::string* ReleaseTransactionLock::release_lock() {
  clear_has_lock();
  if (lock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lock_;
    lock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string operation = 2;
inline bool ReleaseTransactionLock::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReleaseTransactionLock::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReleaseTransactionLock::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReleaseTransactionLock::clear_operation() {
  if (operation_ != &::google::protobuf::internal::kEmptyString) {
    operation_->clear();
  }
  clear_has_operation();
}
inline const ::std::string& ReleaseTransactionLock::operation() const {
  return *operation_;
}
inline void ReleaseTransactionLock::set_operation(const ::std::string& value) {
  set_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    operation_ = new ::std::string;
  }
  operation_->assign(value);
}
inline void ReleaseTransactionLock::set_operation(const char* value) {
  set_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    operation_ = new ::std::string;
  }
  operation_->assign(value);
}
inline void ReleaseTransactionLock::set_operation(const char* value, size_t size) {
  set_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    operation_ = new ::std::string;
  }
  operation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseTransactionLock::mutable_operation() {
  set_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    operation_ = new ::std::string;
  }
  return operation_;
}
inline ::std::string* ReleaseTransactionLock::release_operation() {
  clear_has_operation();
  if (operation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operation_;
    operation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StatusAck

// optional bool status = 1;
inline bool StatusAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusAck::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool StatusAck::status() const {
  return status_;
}
inline void StatusAck::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// NodeAdditionFinalAck

// required bool status = 1;
inline bool NodeAdditionFinalAck::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeAdditionFinalAck::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeAdditionFinalAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeAdditionFinalAck::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool NodeAdditionFinalAck::status() const {
  return status_;
}
inline void NodeAdditionFinalAck::set_status(bool value) {
  set_has_status();
  status_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace network_messages

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< network_messages::NodeStatusEnum>() {
  return network_messages::NodeStatusEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_src_2fcommunication_5fprotocol_2fmessage_5fbinding_2eproto__INCLUDED
